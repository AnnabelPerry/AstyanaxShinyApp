names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
for(GO in 1:length(GO_ID_vec)){
# Output GO ID
GO_df$`GO ID`[GO] <- GO_ID_vec[GO]
# Output GO term, if present
if(GO_ID_vec[GO] %in% GoIDToNames$GO.ID){
GO_df$`GO Term`[GO] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == GO_ID_vec[GO]]
}else{
GO_df$`GO Term`[GO] <- "Not applicable"
}
# Output class of GO ID
if(GO_ID_vec[GO] %in% GO_classes$GO_ID){
GO_df$Namespace[GO] <- GO_classes$Namespace[GO_classes$GO_ID == GO_ID_vec[GO]]
}else{
GO_df$Namespace[GO] <- "Not applicable"
}
# Output all lower-level GO IDs associated with current GO ID
# First, add the current GO ID to a vector
lower_GOs <- GO_ID_vec[GO]
for(g in 1:length(lower_GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(lower_GOs[g] %in% UpperLower$Upper){
lower_GOs <- append(lower_GOs,
UpperLower$Lower[UpperLower$Upper == lower_GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column,
# skip it
}else{
next
}
}
# Remove the first GO ID from the vector of lower GO IDs, as this is the
# original GO ID
lower_GOs <- lower_GOs[-1]
if(length(lower_GOs) != 0){
GO_df$`All Nested GO IDs`[GO] <- paste(lower_GOs, collapse = "; ")
}else{
GO_df$`All Nested GO IDs`[GO] <- "No lower-level GO IDs"
}
}
GO_ID_vec
# In this function, the user inputs GO ID(s) or a phrase and the function
# outputs the class, lower-level GO IDs, and GO term associated with each
# relevant GO ID
GOInfo <- function(GO_input, GO_classes, GOIDToNames, UpperLower, all.GO_IDs){
# Initialize a vector in which to store GO IDs
GO_ID_vec <- c()
# Initialize an empty dataframe to output in the event of an error
error.df <- data.frame(matrix(nrow = 1, ncol = 4))
names(error.df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
# Initialize a vector in which to output warnings/errors
wrnings <- c("Notes: ")
# Find whether input is comma-separated list of GO IDs, single GO ID, or
# phrase and fill GO_ID_vec with appropriate GO IDs based on answer
if((grepl(", ", GO_input))){
# If input is a comma-separated list of GO IDs, parse string and add
# each GO ID to the vector of GO IDs
temp_GO_ID_vec <- str_split(string = GO_input, pattern = ", ")[[1]]
# Check to ensure that at least one of the inputted IDs is a real GO ID
for(i in 1:length(temp_GO_ID_vec)){
if(temp_GO_ID_vec[i] %in% all.GO_IDs){
GO_ID_vec <- append(GO_ID_vec, temp_GO_ID_vec[i])
next
}else{
wrnings <- append(wrnings, paste(c("Input ",temp_GO_ID_vec[i],
" is not a GO ID."),
collapse = ""))
next
}
}
# If NONE of the inputs are real GO IDs, output an error
if(is.null(GO_ID_vec)){
return(list("ERROR: None of the inputs in the comma-separated list are GO IDs",
error.df))
}
}else if(!(grepl(", ", GO_input)) & (GO_input %in% all.GO_IDs)){
# If input is a single GO ID, add it to the vector of GO IDs
GO_ID_vec <- GO_input
}else if(!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)){
# If input is a phrase, find all GO terms associated with that phrase
if(sum(grepl(GO_input, GoIDToNames$GO.Term)) != 0){
GO_ID_vec <- GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term)]
# If NO GO terms are associated with the phrase, output an error
}else{
return(list(paste(c("ERROR: Input ", GO_input,
" is neither a GO ID nor a phrase associated with any recorded GO IDs"),
collapse = ""), error.df))
}
}
# Create a dataframe with the GO terms, namespaces, and lower-level GO IDs
# associated with all input GO IDs
GO_df <- data.frame(matrix(nrow = length(GO_ID_vec), ncol = 4))
names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
for(GO in 1:length(GO_ID_vec)){
# Output GO ID
GO_df$`GO ID`[GO] <- GO_ID_vec[GO]
# Output GO term, if present
if(GO_ID_vec[GO] %in% GoIDToNames$GO.ID){
GO_df$`GO Term`[GO] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == GO_ID_vec[GO]]
}else{
GO_df$`GO Term`[GO] <- "Not applicable"
}
# Output class of GO ID
if(GO_ID_vec[GO] %in% GO_classes$GO_ID){
GO_df$Namespace[GO] <- GO_classes$Namespace[GO_classes$GO_ID == GO_ID_vec[GO]]
}else{
GO_df$Namespace[GO] <- "Not applicable"
}
# Output all lower-level GO IDs associated with current GO ID
# First, add the current GO ID to a vector
lower_GOs <- GO_ID_vec[GO]
for(g in 1:length(lower_GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(lower_GOs[g] %in% UpperLower$Upper){
lower_GOs <- append(lower_GOs,
UpperLower$Lower[UpperLower$Upper == lower_GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column,
# skip it
}else{
next
}
}
# Remove the first GO ID from the vector of lower GO IDs, as this is the
# original GO ID
lower_GOs <- lower_GOs[-1]
if(length(lower_GOs) != 0){
GO_df$`All Nested GO IDs`[GO] <- paste(lower_GOs, collapse = "; ")
}else{
GO_df$`All Nested GO IDs`[GO] <- "No lower-level GO IDs"
}
}
# Return data frame and warnings, if applicable
return(list(wrnings, GO_df))
}
GOInfo(GO_input = "GO:0000001, y",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
View(GO_classes)
View(GoIDToNames)
GOInfo(GO_input = "GO:, y",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
GOInfo(GO_input = "nothing",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
GOInfo(GO_input = "GO:0000010, y",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
GOInfo(GO_input = "GO:0000010, GO:0000052",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
# In this function, the user inputs GO ID(s) or a phrase and the function
# outputs the class, lower-level GO IDs, and GO term associated with each
# relevant GO ID
GOInfo <- function(GO_input, GO_classes, GOIDToNames, UpperLower, all.GO_IDs){
# Initialize a vector in which to store GO IDs
GO_ID_vec <- c()
# Initialize an empty dataframe to output in the event of an error
error.df <- data.frame(matrix(nrow = 1, ncol = 4))
names(error.df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
# Initialize a vector in which to output warnings/errors
wrnings <- c("Notes: ")
# Find whether input is comma-separated list of GO IDs, single GO ID, or
# phrase and fill GO_ID_vec with appropriate GO IDs based on answer
if((grepl(", ", GO_input))){
# If input is a comma-separated list of GO IDs, parse string and add
# each GO ID to the vector of GO IDs
temp_GO_ID_vec <- str_split(string = GO_input, pattern = ", ")[[1]]
# Check to ensure that at least one of the inputted IDs is a real GO ID
for(i in 1:length(temp_GO_ID_vec)){
if(temp_GO_ID_vec[i] %in% all.GO_IDs){
GO_ID_vec <- append(GO_ID_vec, temp_GO_ID_vec[i])
next
}else{
wrnings <- append(wrnings, paste(c("Input ",temp_GO_ID_vec[i],
" is not a GO ID."),
collapse = ""))
next
}
}
# If NONE of the inputs are real GO IDs, output an error
if(is.null(GO_ID_vec)){
return(list("ERROR: None of the inputs in the comma-separated list are GO IDs",
error.df))
}
}else if(!(grepl(", ", GO_input)) & (GO_input %in% all.GO_IDs)){
# If input is a single GO ID, add it to the vector of GO IDs
GO_ID_vec <- GO_input
}else if(!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)){
# If input is a phrase, find all GO terms associated with that phrase
if(sum(grepl(GO_input, GoIDToNames$GO.Term)) != 0){
GO_ID_vec <- GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term,
ignore.case = T)]
# If NO GO terms are associated with the phrase, output an error
}else{
return(list(paste(c("ERROR: Input ", GO_input,
" is neither a GO ID nor a phrase associated with any recorded GO IDs"),
collapse = ""), error.df))
}
}
# Create a dataframe with the GO terms, namespaces, and lower-level GO IDs
# associated with all input GO IDs
GO_df <- data.frame(matrix(nrow = length(GO_ID_vec), ncol = 4))
names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
for(GO in 1:length(GO_ID_vec)){
# Output GO ID
GO_df$`GO ID`[GO] <- GO_ID_vec[GO]
# Output GO term, if present
if(GO_ID_vec[GO] %in% GoIDToNames$GO.ID){
GO_df$`GO Term`[GO] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == GO_ID_vec[GO]]
}else{
GO_df$`GO Term`[GO] <- "Not applicable"
}
# Output class of GO ID
if(GO_ID_vec[GO] %in% GO_classes$GO_ID){
GO_df$Namespace[GO] <- GO_classes$Namespace[GO_classes$GO_ID == GO_ID_vec[GO]]
}else{
GO_df$Namespace[GO] <- "Not applicable"
}
# Output all lower-level GO IDs associated with current GO ID
# First, add the current GO ID to a vector
lower_GOs <- GO_ID_vec[GO]
for(g in 1:length(lower_GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(lower_GOs[g] %in% UpperLower$Upper){
lower_GOs <- append(lower_GOs,
UpperLower$Lower[UpperLower$Upper == lower_GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column,
# skip it
}else{
next
}
}
# Remove the first GO ID from the vector of lower GO IDs, as this is the
# original GO ID
lower_GOs <- lower_GOs[-1]
if(length(lower_GOs) != 0){
GO_df$`All Nested GO IDs`[GO] <- paste(lower_GOs, collapse = "; ")
}else{
GO_df$`All Nested GO IDs`[GO] <- "No lower-level GO IDs"
}
}
# Return data frame and warnings, if applicable
return(list(wrnings, GO_df))
}
GOInfo(GO_input = "SlEeP",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
GOInfo(GO_input = "sleep",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
# In this function, the user inputs GO ID(s) or a phrase and the function
# outputs the class, lower-level GO IDs, and GO term associated with each
# relevant GO ID
GOInfo <- function(GO_input, GO_classes, GOIDToNames, UpperLower, all.GO_IDs){
# Initialize a vector in which to store GO IDs
GO_ID_vec <- c()
# Initialize an empty dataframe to output in the event of an error
error.df <- data.frame(matrix(nrow = 1, ncol = 4))
names(error.df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
# Initialize a vector in which to output warnings/errors
wrnings <- c("Notes: ")
# Find whether input is comma-separated list of GO IDs, single GO ID, or
# phrase and fill GO_ID_vec with appropriate GO IDs based on answer
if((grepl(", ", GO_input))){
# If input is a comma-separated list of GO IDs, parse string and add
# each GO ID to the vector of GO IDs
temp_GO_ID_vec <- str_split(string = GO_input, pattern = ", ")[[1]]
# Check to ensure that at least one of the inputted IDs is a real GO ID
for(i in 1:length(temp_GO_ID_vec)){
if(temp_GO_ID_vec[i] %in% all.GO_IDs){
GO_ID_vec <- append(GO_ID_vec, temp_GO_ID_vec[i])
next
}else{
wrnings <- append(wrnings, paste(c("Input ",temp_GO_ID_vec[i],
" is not a GO ID."),
collapse = ""))
next
}
}
# If NONE of the inputs are real GO IDs, output an error
if(is.null(GO_ID_vec)){
return(list("ERROR: None of the inputs in the comma-separated list are GO IDs",
error.df))
}
}else if(!(grepl(", ", GO_input)) & (GO_input %in% all.GO_IDs)){
# If input is a single GO ID, add it to the vector of GO IDs
GO_ID_vec <- GO_input
}else if(!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)){
# If input is a phrase, find all GO terms associated with that phrase
if(sum(grepl(GO_input, GoIDToNames$GO.Term, ignore.case = T)) != 0){
GO_ID_vec <- GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term,
ignore.case = T)]
# If NO GO terms are associated with the phrase, output an error
}else{
return(list(paste(c("ERROR: Input ", GO_input,
" is neither a GO ID nor a phrase associated with any recorded GO IDs"),
collapse = ""), error.df))
}
}
# Create a dataframe with the GO terms, namespaces, and lower-level GO IDs
# associated with all input GO IDs
GO_df <- data.frame(matrix(nrow = length(GO_ID_vec), ncol = 4))
names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
for(GO in 1:length(GO_ID_vec)){
# Output GO ID
GO_df$`GO ID`[GO] <- GO_ID_vec[GO]
# Output GO term, if present
if(GO_ID_vec[GO] %in% GoIDToNames$GO.ID){
GO_df$`GO Term`[GO] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == GO_ID_vec[GO]]
}else{
GO_df$`GO Term`[GO] <- "Not applicable"
}
# Output class of GO ID
if(GO_ID_vec[GO] %in% GO_classes$GO_ID){
GO_df$Namespace[GO] <- GO_classes$Namespace[GO_classes$GO_ID == GO_ID_vec[GO]]
}else{
GO_df$Namespace[GO] <- "Not applicable"
}
# Output all lower-level GO IDs associated with current GO ID
# First, add the current GO ID to a vector
lower_GOs <- GO_ID_vec[GO]
for(g in 1:length(lower_GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(lower_GOs[g] %in% UpperLower$Upper){
lower_GOs <- append(lower_GOs,
UpperLower$Lower[UpperLower$Upper == lower_GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column,
# skip it
}else{
next
}
}
# Remove the first GO ID from the vector of lower GO IDs, as this is the
# original GO ID
lower_GOs <- lower_GOs[-1]
if(length(lower_GOs) != 0){
GO_df$`All Nested GO IDs`[GO] <- paste(lower_GOs, collapse = "; ")
}else{
GO_df$`All Nested GO IDs`[GO] <- "No lower-level GO IDs"
}
}
# Return data frame and warnings, if applicable
return(list(wrnings, GO_df))
}
GOInfo(GO_input = "sleep",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
x <- GOInfo(GO_input = "sleep",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
y <- GOInfo(GO_input = "SlEeP",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
x_2 <- x[[2]]
y_2 <- y[[2]]
View(x_2)
View(y_2)
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
GOInfo(GO:0035639)
GOInfo(GO_input = "GO:0035639",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
x <- GOInfo(GO_input = "GO:0035639",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
x_2 <- x[[2]]
View(x_2)
x <- GOInfo(GO_input = "sLeEP",
GO_classes = GO_classes,
GOIDToNames = GOIDToNames,
UpperLower = UpperLower,
all.GO_IDs = all.GO_IDs)
x <- x[[2]]
View(x)
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
GO_input = "sleep"
GOInfo(
GO_input,
GO_classes,
GOIDToNames,
UpperLower,
all.GO_IDs
)
length(GOInfo(
GO_input,
GO_classes,
GOIDToNames,
UpperLower,
all.GO_IDs
))
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
as.data.frame(c("Data will populate here once GO ID or phrase is inputted."))
as.data.frame("Data will populate here once GO ID or phrase is inputted.")
data.frame("Data will populate here once GO ID or phrase is inputted.")
data.frame(Data = "Data will populate here once GO ID or phrase is inputted.")
data.frame(`"Column Name"` = "Data will populate here once GO ID or phrase is inputted.")
data.frame(`Column Name` = "Data will populate here once GO ID or phrase is inputted.")
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
GO_input = sleep
# Initialize a vector in which to store GO IDs
GO_ID_vec <- c()
# Initialize an empty dataframe to output in the event of an error
error.df <- data.frame(matrix(nrow = 1, ncol = 4))
names(error.df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
# Initialize a vector in which to output warnings/errors
wrnings <- c("Notes: ")
!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)
!(GO_input %in% all.GO_IDs)
!(grepl(", ", GO_input))
GO_input
GO_input = "sleep"
GO_input
!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)
sum(grepl(GO_input, GoIDToNames$GO.Term, ignore.case = T)) != 0
GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term,
ignore.case = T)]
GO_ID_vec <- GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term,
ignore.case = T)]
# Create a dataframe with the GO terms, namespaces, and lower-level GO IDs
# associated with all input GO IDs
GO_df <- data.frame(matrix(nrow = length(GO_ID_vec), ncol = 4))
names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
GO_ID_vec
length(GO_ID_vec)
runApp('CaveCrawler.R')
GO = 5
GO_ID_vec[GO]
GO_ID_vec[GO] %in% GoIDToNames$GO.ID
sum(GoIDToNames$GO.ID == GO_ID_vec[GO])
GoIDToNames$GO.Term[GoIDToNames$GO.ID == GO_ID_vec[GO]]
GO_ID_vec[GO]
GoIDToNames <- read.table("data/GOIDs_and_Names.txt", fill = T, sep = "\t", header = T)
View(GoIDToNames)
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543"]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543",]
GoIDToNames[755,]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543",]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039544",]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543",]
which(GoIDToNames$GO.ID == "GO:0039543")
GoIDToNames$GO.Term[grepl("\n", GoIDToNames$GO.Term)]
# When you first read in GoIDToNames, some entire lines are, for whatever reason,
# combined into a single GO term cell
# This section of the script...
# 1. Identifies all GO term cells containing information from multiple lines
messed_cells <- GoIDToNames$GO.Term[grepl("\n", GoIDToNames$GO.Term)]
lirary(stringr)
library(stringr)
