# Initialize vector for all GO terms of interest
GOs <- c()
# Initialize vector in which to store warnings
wrnings <- c("Notes: ")
# Check if user inputted a word/phrase or a GO ID. If the user inputted a
# word/phrase, find the name(s) which contains that word/phrase and set the GO
# vector equal to the corresponding GO IDs.
if(!(GOTerm %in% MasterGO$GO_ID)){
if(length(MasterGO$GO_ID[which(grepl(GOTerm, MasterGO$GO_Term,
ignore.case = T))]) != 0){
GOs <- MasterGO$GO_ID[which(grepl(GOTerm, MasterGO$GO_Term,
ignore.case = T))]
# If the input is not found in the GO terms but does have a comma,
# output both as GO IDs and check whether they are valid GO IDs
}else if((length(MasterGO$GO_ID[which(grepl(GOTerm, MasterGO$GO_Term,
ignore.case = T))]) == 0)
& (grepl(", ", GOTerm, ignore.case = T))){
GOs <- str_split(GOTerm, ", ")[[1]]
# If the input is not found in the GO terms and does not have a comma,
# return an error
}else if((length(MasterGO$GO_ID[which(grepl(GOTerm, MasterGO$GO_Term,
ignore.case = T))]) == 0)
& !(grepl(", ", GOTerm, ignore.case = T))){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: Input is neither a valid GO ID nor a valid phrase",
null.df))
}
# If user inputted a GO ID, add that ID
}else if(GOTerm %in% MasterGO$GO_ID){
GOs <- GOTerm
}
# Find all GO terms which are LOWER than the GO terms in the GO vector.
# First, loop through each GO ID in the vector-of-GOs. As more GO IDs, are
# added to the vector, the number of remaining iterations will increase.
for(g in 1:length(GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(GOs[g] %in% UpperLower$Upper){
GOs <- append(GOs, UpperLower$Lower[UpperLower$Upper == GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column, skip it
}else{
next
}
}
# Find all gene IDs associated with the current GO IDs and add to vector of gene IDs
GeneID_vec <- c()
found_GOs <- c()
for(g in 1:length(GOs)){
found = F
# If the GO term appears in the data frame of names AND the corresponding gene
# occurs in the statistics vector, add the GO term and gene name
for(i in 1:length(GeneToGO$Gene.ontology.IDs)){
if(grepl(GOs[g], GeneToGO$Gene.ontology.IDs[i])){
found = T
}else{
next
}
}
if(found){
GeneID_vec <- append(GeneID_vec, GeneToGO$Ensembl_GeneID[grepl(GOs[g],
GeneToGO$Gene.ontology.IDs)])
found_GOs <- append(found_GOs, rep(GOs[g],
length(GeneToGO$Ensembl_GeneID[grepl(GOs[g],
GeneToGO$Gene.ontology.IDs)])))
# If the GO term does NOT appear in the dataframe of names, skip it
}else{
next
}
}
# If no gene IDs were found corresponding to the current GO ID, return an error
if(is.null(GeneID_vec)){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("No genes were found corresponding to any of the input IDs or phrase",
null.df))
}else{
geneGOs <- data.frame(
GeneID = GeneID_vec,
GO_ID = found_GOs
)
geneGOs <- geneGOs[!duplicated(geneGOs), ]
}
# Extract all possible combinations of populations from populations of interest
if(("Fst" %in% stat_vec) | ("Dxy" %in% stat_vec)){
all_pops <- combn(pops,2)
two_pop <- T
}else{
two_pop <- F
}
# Create a temporary dataframe for all possible combinations of statistic
# types, columns, and the populations to which they correspond
stat_pop_combos <- data.frame(matrix(ncol = 3))
colnames(stat_pop_combos) <- c("Stat_Type", "Pop", "Col")
for(s in 1:length(stat_vec)){
# Check if statistic of interest makes comparisons between TWO populations
if((stat_vec[s] == "Fst") | (stat_vec[s] == "Dxy")){
# Check if all_pops was created
if(two_pop){
# If so, iterate through each combination and output stat value for that
# combination
for(pair in 1:ncol(all_pops)){
# If pops is a matrix, read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "index" equal to the column housing this statistic
val <- which(grepl(all_pops[1, pair], names(stat_table))
& grepl(all_pops[2, pair], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, add a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the populations ",
all_pops[1, pair]," and ",
all_pops[2, pair], " | "),collapse = ""))
# If these populations-of-interest are the only pops which were
# inputted, return a warning
if(ncol(all_pops) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list(paste(c("Statistic ",stat_vec[s],
" is not present for the populations ",
all_pops[1, pair]," and ",
all_pops[2, pair]),collapse = ""), null.df))
}
}else{
# Create a row to add to the indices data frame
temp_str <- paste(c(all_pops[1, pair],"-",all_pops[2, pair]),
collapse = "")
temp_vec <- c(stat_vec[s],temp_str,val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
# If pops is NOT a matrix, return an error
}
}else{
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list(paste(c("ERROR: Only one population, ", pops,
", supplied for the two-population statistic ",
stat_vec[s], "."),
collapse = ""), null.df))
# Check if statistic of interest makes comparisons between ONE population
}
}else if((stat_vec[s] == "TajimasD") | (stat_vec[s] == "Pi")){
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
val <- which(grepl(pops[p], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, return a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the population ",
pops[p], " | "), collapse = ""))
}else{
# Create a row to add to the indices dataframe
temp_vec <- c(stat_vec[s],pops[p],val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
}
}
}
# If NONE of the populations-of-interest had values for the statistics-of-
# interest, output an error
if(nrow(stat_pop_combos) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: None of the input statistics are present for any of the input populations",
null.df))
}
# If dataframe was valid, remove first row (as this is all NAs from)
# initialization
stat_pop_combos <- stat_pop_combos[-1,]
# For each GO Term in the vector of GO Terms-of-interest, find...
# 1. All gene names which occur in the positions table AND in the statistics
#    table
# 2. The scaffolds of those genes
# 3. The starting positions of those genes
# 4. The ending positions of those genes
# 5. The GO terms associated with those genes
# 6. Each of the 4 statistic types
# 7. Each of the populations/population combinations
# 8. Each of the statistical values
# 9. Publication from which the statistic value was derived
# For each statistic-population pair, iterate through each gene and find the
# statistic value, scaffold, starting position, and ending position and
# output to a dataframe
GeneID <- c()
Scaffold <- c()
Start_Position <- c()
End_Position <- c()
GO_IDs <- c()
Statistic_Type <- c()
Population <- c()
Statistic_Value <- c()
Publication_Number <- c()
for(i in 1:nrow(stat_pop_combos)){
for(g in 1:length(geneGOs$Gene)){
# Check if current gene ID is in stat AND position table
# If so...
if((geneGOs$GeneID[g] %in% stat_table$Stable_Gene_ID) &
(geneGOs$GeneID[g] %in% position_table$Gene_ID)){
# Find the number of copies of the current gene ID in the statistic
# table
copies <- length(stat_table[stat_table$Stable_Gene_ID == geneGOs$GeneID[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the current gene as many times as there are copies
GeneID <- append(GeneID, rep(geneGOs$GeneID[g], copies))
# Output scaffold of current gene as many times as there are copies
Scaffold <- append(Scaffold,
rep(position_table$Scaffold[position_table$Gene_ID == geneGOs$GeneID[g]],
copies))
# Output starting position of the current gene as many times as
# there are copies of the gene
Start_Position <- append(Start_Position,
rep(position_table$Start_Locus[position_table$Gene_ID == geneGOs$GeneID[g]],
copies))
# Output the ending position of the current gene as many times as
# there are copies of the gene
End_Position <- append(End_Position,
rep(position_table$End_Locus[position_table$Gene_ID == geneGOs$GeneID[g]],
copies))
# Output ALL GO terms associated with the current gene ID as many times
# as there are copies of the gene
GO_IDs <- append(GO_IDs,
rep(
paste(geneGOs$GO_ID[geneGOs$GeneID == geneGOs$GeneID[g]], collapse = "; "),
copies))
# Output the current statistic type as many times as there are copies
# of the gene
Statistic_Type <- append(Statistic_Type,
rep(stat_pop_combos$Stat_Type[i],
copies))
# Output the population(s) which correspond to the current column,
# and output as many times as there are copies of the gene.
Population <- append(Population, rep(stat_pop_combos$Pop[i],
copies))
# Output the statistic value. Will automatically output value for
# each copy of the gene.
Statistic_Value <- append(Statistic_Value,
stat_table[stat_table$Stable_Gene_ID == geneGOs$GeneID[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the publication from which the statistic was obtained
Publication_Number <- append(Publication_Number,
stat_table$Publication[stat_table$Stable_Gene_ID == geneGOs$GeneID[g]])
# If not, skip the gene
}else{
next
}
}
}
output_df <- data.frame(GeneID,
Scaffold,
Start_Position,
End_Position,
GO_IDs,
Statistic_Type,
Population,
Statistic_Value,
Publication_Number
)
# Remove all values where the stat-of-interest is NA
output_df <- output_df[!is.na(output_df$Statistic_Value), ]
return(list(wrnings, output_df))
}
GOTerm = "GO:0007034"
stat_vec = "Fst"
pops = c("Pachon","Molino")
StatByChrTable(GOTerm, GeneToGo, MasterGO, UpperLower,
stat_vec, position_table, stat_table, pops)
x<-StatByChrTable(GOTerm, GeneToGo, MasterGO, UpperLower,
stat_vec, position_table, stat_table, pops)
StatByChrGraph(x[[2]])
StatByChrGraph(x[[2]], stat_vec = "Fst")
library(ggplot2)
StatByChrGraph(x[[2]], stat_vec = "Fst")
in_type = "Statistic Value"
UL = "top"
stat = "Fst"
thresh = 0.95
pops = c("Rascon","Pachon","Molino")
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
library(stringr)
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
library(tibble)
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
StatDistTable(in_type, UL = "bottom", stat, thresh, stat_table, pops)
StatDistTable(in_type, UL = "bottom", stat, thresh = 0.05, stat_table, pops)
StatDistTable(in_type, UL = "bottom", stat, thresh = 0.001, stat_table, pops)
StatDistPlot(stat, UL, thresh, stat_table, pops)
library(WVPlots)
StatDistPlot(stat, UL, thresh, stat_table, pops)
in_type = "Gene Count" UL = "top" stat = "Fst" thresh = 10 pops = c("Rascon","Pachon","Molino")
in_type = "Gene Count"
UL = "top"
stat = "Fst"
thresh = 10
pops = c("Rascon","Pachon","Molino")
StatDistPlot(stat, UL, thresh, stat_table, pops)
StatDistTable(in_type, UL = "bottom", stat, thresh = 0.001, stat_table, pops)
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
View(stat_table)
runApp('CaveCrawler.R')
transcBool <- T
popgenBool <- T
transcBool <- F
GOBool <- F
posBool <- F
# Initialize warnings
warn <- c("Notes: ")
# Output warnings if data was not requested so the user does not get confused
# by the lack of output
if(posBool == F){
warn <- append(warn, "Position table is blank because position information was not requested.")
}
if(transcBool == F){
warn <- append(warn, "Transcription table is blank because transcription information was not requested.")
}
if(popgenBool == F){
warn <- append(warn, "Population genetics table is blank because Population genetics information was not requested.")
}
if(GOBool == F){
warn <- append(warn, "GO table is blank because GO information was not requested.")
}
# Define a comma
comma <- ", "
# Define a vector in which to store all inputs
input_vec <- c()
# Check if comma occurs in input string
if(grepl(comma, input)){
# If so, split the input string and add each individual input to the input
# vector
input_vec <- str_split(input, pattern = comma)[[1]]
}else{
# If not, add the whole string to the input vector
input_vec <- input
}
# Define a vector in which to store gene IDs
geneIDs <- c()
# Iterate through each entry in vector of inputs to find the IDs corresponding
# to these inputs
for(i in 1:length(input_vec)){
# Check if current entry is a gene ID
if(grepl("ENSAMXG", input_vec[i])){
# If current entry IS a gene ID, simply append to vector of IDs
geneIDs <- append(geneIDs, input_vec[i])
}else{
# If current entry is NOT a gene ID, convert to lowercase and grep all
# lower-case gene name and gene info columns for this string.
searchTerm <- tolower(input_vec[i])
tempIDs <- c()
# grep every gene name in position table (use grep instead of %in% for
# partial gene name matching)
for(g in 1:nrow(position_table)){
if(grepl(searchTerm, tolower(position_table$Gene_Name[g]))){
tempIDs <- append(tempIDs, position_table$Gene_ID[g])
}
}
# statistic table
for(s in 1:nrow(stat_table)){
# If current entry is part of the gene name, description, OR GO terms,
# add the ID to the vector of IDs
if((grepl(searchTerm, tolower(stat_table$Gene_Name[s]))) |
(grepl(searchTerm, tolower(stat_table$Gene_Description[s]))) |
(grepl(searchTerm, tolower(stat_table$GO_Terms[s])))){
tempIDs <- append(tempIDs, stat_table$Stable_Gene_ID[s])
}
}
# transcription tables
for(t in 1:nrow(morph1.morph2)){
# If current entry is part of the gene name or study-specific details,
# add the ID to the vector of IDs
if((grepl(searchTerm, tolower(morph1.morph2$Gene_name[t]))) |
(grepl(searchTerm, tolower(morph1.morph2$study_specific_gene_details[t])))){
tempIDs <- append(tempIDs, morph1.morph2$Gene_stable_ID[t])
}
}
for(t in 1:nrow(condition_control)){
# If current entry is part of the gene name, gene description, or Ensembl
# description, add the ID to the vector of IDs
if((grepl(searchTerm, tolower(condition_control$Gene_name[t]))) |
(grepl(searchTerm, tolower(condition_control$Gene_description[t]))) |
(grepl(searchTerm, tolower(condition_control$Ensembl_Family_Description[t])))){
tempIDs <- append(tempIDs, condition_control$Gene_stable_ID[t])
}
}
# GO table
for(go in 1:nrow(GeneToGO)){
# If current entry is found in the gene name or any of the GO info, add
# the ID corresponding to this information to the vector of gene IDs
if((grepl(searchTerm, tolower(GeneToGO$Gene.names[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology..biological.process.[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology..cellular.component.[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology..molecular.function.[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology.IDs[go])))){
tempIDs <- append(tempIDs, GeneToGO$Ensembl_GeneID[go])
}
}
# If no info is found for the current ID, append a warning and skip
if(length(tempIDs) == 0){
warn <- append(warn, paste(c("No genes found corresponding to the input",
input_vec[i]), collapse = " "))
}else{
# Once ID(s) corresponding to this entry are found, remove duplicate/NA IDs,
# append the IDs to the gene ID vector, then move to the next entry
geneIDs <- append(geneIDs, tempIDs[!duplicated(tempIDs) &
!grepl("NA", tempIDs) &
!is.na(tempIDs)])
next
}
}
}
geneIDs
# Initialize final dataframes in which to store data corresponding to ALL gene
# IDs
finalPos <- data.frame(matrix(nrow = length(geneIDs), ncol = 6))
finalGO <- data.frame(matrix(nrow = length(geneIDs), ncol = 7))
# Do not give row names for transcription or popgen data because there could
# be multiple rows per gene
finalTransc <- data.frame(matrix(ncol = 9))
finalPopgen <- data.frame(matrix(ncol = 8))
names(finalPos) <- c("Gene ID",
"Gene name",
"Scaffold",
"Start Locus",
"End Locus",
"Publication")
names(finalTransc) <- c("Gene ID",
"Gene name",
"Gene description",
"Study-specific information",
"Comparison",
"logFC",
"p-value",
"Condition",
"Publication")
names(finalPopgen) <- c("Gene ID",
"Gene name",
"Gene description",
"Statistic Type",
"Population(s)",
"Statistic Value",
"Study-specific information",
"Publication")
names(finalGO) <- c("Gene ID",
"Gene name",
"Gene Ontology IDs",
"Biological Process",
"Cellular Component",
"Molecular Function",
"Publication")
# If no info was found for ANY of the entries, output an ERROR
if(length(geneIDs) == 0){
warn <- paste(c("Error: No genes can be described by any of these inputs:",
input), collapse = "\n")
return(list(finalPos, finalTransc, finalPopgen, tempGO, warn))
}
i
geneIDs[i] %in% stat_table$Stable_Gene_ID
ncol(stat_table)
stat_table[,-(stat_table$Publication &
stat_table$Fst_Outliers)]
ncol(stat_table[,stat_table$Publication])
for(i in 1:ncol(stat_table)){typeof(stat_table[,i])}
for(i in 1:ncol(stat_table)){print(typeof(stat_table[,i]))}
c
typeof(stat_table[,c]) == "double"
runApp('CaveCrawler.R')
