GOInfo(
GO_input,
GO_classes,
GOIDToNames,
UpperLower,
all.GO_IDs
)
length(GOInfo(
GO_input,
GO_classes,
GOIDToNames,
UpperLower,
all.GO_IDs
))
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
as.data.frame(c("Data will populate here once GO ID or phrase is inputted."))
as.data.frame("Data will populate here once GO ID or phrase is inputted.")
data.frame("Data will populate here once GO ID or phrase is inputted.")
data.frame(Data = "Data will populate here once GO ID or phrase is inputted.")
data.frame(`"Column Name"` = "Data will populate here once GO ID or phrase is inputted.")
data.frame(`Column Name` = "Data will populate here once GO ID or phrase is inputted.")
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
GO_input = sleep
# Initialize a vector in which to store GO IDs
GO_ID_vec <- c()
# Initialize an empty dataframe to output in the event of an error
error.df <- data.frame(matrix(nrow = 1, ncol = 4))
names(error.df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
# Initialize a vector in which to output warnings/errors
wrnings <- c("Notes: ")
!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)
!(GO_input %in% all.GO_IDs)
!(grepl(", ", GO_input))
GO_input
GO_input = "sleep"
GO_input
!(grepl(", ", GO_input)) & !(GO_input %in% all.GO_IDs)
sum(grepl(GO_input, GoIDToNames$GO.Term, ignore.case = T)) != 0
GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term,
ignore.case = T)]
GO_ID_vec <- GoIDToNames$GO.ID[grepl(GO_input, GoIDToNames$GO.Term,
ignore.case = T)]
# Create a dataframe with the GO terms, namespaces, and lower-level GO IDs
# associated with all input GO IDs
GO_df <- data.frame(matrix(nrow = length(GO_ID_vec), ncol = 4))
names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
GO_ID_vec
length(GO_ID_vec)
runApp('CaveCrawler.R')
GO = 5
GO_ID_vec[GO]
GO_ID_vec[GO] %in% GoIDToNames$GO.ID
sum(GoIDToNames$GO.ID == GO_ID_vec[GO])
GoIDToNames$GO.Term[GoIDToNames$GO.ID == GO_ID_vec[GO]]
GO_ID_vec[GO]
GoIDToNames <- read.table("data/GOIDs_and_Names.txt", fill = T, sep = "\t", header = T)
View(GoIDToNames)
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543"]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543",]
GoIDToNames[755,]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543",]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039544",]
GoIDToNames[GoIDToNames$GO.ID == "GO:0039543",]
which(GoIDToNames$GO.ID == "GO:0039543")
GoIDToNames$GO.Term[grepl("\n", GoIDToNames$GO.Term)]
# When you first read in GoIDToNames, some entire lines are, for whatever reason,
# combined into a single GO term cell
# This section of the script...
# 1. Identifies all GO term cells containing information from multiple lines
messed_cells <- GoIDToNames$GO.Term[grepl("\n", GoIDToNames$GO.Term)]
lirary(stringr)
library(stringr)
View(GeneToGO)
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
grepl("Fst", names(stat_table), ignore.case = T)
stat_table[,grepl("Fst", names(stat_table), ignore.case = T)]
morphs = c("Pachon","Rascon")
grepl(morphs, names(stat_table), ignore.case = T)
for(m in 1:length(morphs)){
grepl(morphs[m], names(stat_table), ignore.case = T)
}
matrix(nrow = length(morphs), ncol = ncol(stat_table))
output$test <- renderText(
x <- matrix(nrow = length(morphs), ncol = ncol(stat_table))
for(m in 1:length(morphs)){
x[m] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
stat_table[,(grepl("Fst", names(stat_table), ignore.case = T)
& ()
& ]
if(input$dist_statist == "Fst"){
paste(c("Minimum: ", ". Maximum: ",), collapse = "")
}else if(input$dist_statist == "Dxy"){
}else if(input$dist_statist == "Pi"){
}else if(input$dist_statist == "TajimasD"){
}
)
}
# Run the application
shinyApp(ui = ui, server = server)
x <- matrix(nrow = length(morphs), ncol = ncol(stat_table))
for(m in 1:length(morphs)){
x[m] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
grepl(morphs[m], names(stat_table), ignore.case = T)
ncol(stat_table)
x[m]
x[m,]
x <- matrix(nrow = length(morphs), ncol = ncol(stat_table))
for(m in 1:length(morphs)){
x[m,] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
View(x)
for(m in 1:length(morphs)){
x[m,] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
View(x)
output$test <- renderText(
# Create matrix to store all columns which house the statistic-of-interest
# AND the populations-of-interest
x <- matrix(nrow = length(morphs), ncol = ncol(stat_table))
names(x) <- names(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(morphs)){
x[m,] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
if(){
}
# Of the columns of stat_table which house at least one morph-of-interest,
# exclude the columns which have morphs which are NOT morphs of interest
if(input$dist_statist == "Fst"){
paste(c("Minimum: ", ". Maximum: ",), collapse = "")
}else if(input$dist_statist == "Dxy"){
}else if(input$dist_statist == "Pi"){
}else if(input$dist_statist == "TajimasD"){
}
)
names(x) <- names(stat_table)
names(x) <- names(stat_table)
colnames(x) <- colnames(stat_table)
x <- data.frame(matrix(nrow = length(morphs), ncol = ncol(stat_table)))
colnames(x) <- colnames(stat_table)
for(m in 1:length(morphs)){
x[m,] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
output$test <- renderText(
# Create matrix to store all columns which house the statistic-of-interest
# AND the populations-of-interest
x <- data.frame(matrix(nrow = length(morphs), ncol = ncol(stat_table)))
colnames(x) <- colnames(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(morphs)){
x[m,] <- grepl(morphs[m], names(stat_table), ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(x)){
if(sum(x[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(x)[i])
}
}
# Of the columns of stat_table which house at least one morph-of-interest,
# exclude the columns which have morphs which are NOT morphs of interest
if(input$dist_statist == "Fst"){
paste(c("Minimum: ", ". Maximum: ",), collapse = "")
}else if(input$dist_statist == "Dxy"){
}else if(input$dist_statist == "Pi"){
}else if(input$dist_statist == "TajimasD"){
}
)
cols.of.interest <- c()
for(i in 1:ncol(x)){
if(sum(x[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(x)[i])
}
}
cols.of.interest
all.morphs <- c("Pachon", "Rascon", "Rio Choy", "Molino", "Tinaja")
MOIs <- morphs
MOIs
all.morphs == MOIs
MOIs
cols.w.morphs <- data.frame(matrix(nrow = length(morphs),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(MOIs)){
cols.w.morphs[m,] <- grepl(MOIs[m], names(stat_table), ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
cols.of.interest
x <- rbind(stat_table$Fst_Pachon.Rascon, stat_table$Fst_Rascon.Tinaja)
View(x)
x <- cbind(stat_table$Fst_Pachon.Rascon, stat_table$Fst_Rascon.Tinaja)
x <- c()
x <- append(x, stat_table$Fst_Pachon.Rascon)
x <- append(x, stat_table$Fst_Rascon.Tinaja)
x
all.morphs[-(MOIs)]
i
i = 1
MOIs[i]
bad.morphs[-(bad.morphs == MOIs[i])]
output$test <- renderText(
# Store morphs-of-interest
MOIs <- input$dist_pops
# Create matrix to store all columns which house the morphs-of-interest
cols.w.morphs <- data.frame(matrix(nrow = length(morphs),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(MOIs)){
cols.w.morphs[m,] <- grepl(MOIs[m], names(stat_table), ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
# Of the columns of stat_table which house at least one morph-of-interest,
# exclude the columns which have morphs which are NOT morphs of interest
bad.morphs <- c("Pachon", "Rascon", "Rio Choy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[-(bad.morphs == MOIs[i])]
}
# Find columns-of-interest which house stat-of-interest
# Combine columns-of-interest into a single vector of numbers
for(){
}
# Output the minimum and maximum values in that vector
minimum <-
maximum <-
paste(c("Minimum: ", minimum, ". Maximum: ", maximum), collapse = "")
)
bad.morphs <- c("Pachon", "Rascon", "Rio Choy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[-(bad.morphs == MOIs[i])]
}
bad.morphs
cols.of.interest
colnames(cols.exc.bad) <- cols.of.interest
cols.exc.bad <- data.frame(matrix(nrow = length(bad.morphs),
ncol = length(cols.of.interest)))
colnames(cols.exc.bad) <- cols.of.interest
cols.exc.bad
b = 1
grepl(bad.morphs[b], cols.of.interest,
ignore.case = T)
sum(grepl(bad.morphs[b], cols.of.interest,
ignore.case = T)) != 0
b = 2
sum(grepl(bad.morphs[b], cols.of.interest,
ignore.case = T)) != 0
cols.of.interest
bad.morphs
b = 1
bad.morphs[b]
output$test <- renderText(
# Store morphs-of-interest
MOIs <- input$dist_pops
# Create matrix to store all columns which house the morphs-of-interest
cols.w.morphs <- data.frame(matrix(nrow = length(MOIs),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(MOIs)){
cols.w.morphs[m,] <- grepl(MOIs[m], names(stat_table), ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
# Of the columns of stat_table which house at least one morph-of-interest,
# exclude the columns which have morphs which are NOT morphs of interest
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[-(bad.morphs == MOIs[i])]
}
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,
ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest(!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T)))
}
}
# Find columns-of-interest which house stat-of-interest
# Combine columns-of-interest into a single vector of numbers
for(){
}
# Output the minimum and maximum values in that vector
minimum <-
maximum <-
paste(c("Minimum: ", minimum, ". Maximum: ", maximum), collapse = "")
)
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[-(bad.morphs == MOIs[i])]
}
bad.morphs[b]
sum(grepl(bad.morphs[b], cols.of.interest,
ignore.case = T))
cols.of.interest(!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T)))
cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
MOIs <- c("Rascon","Pachon","Tinaja")
cols.w.morphs <- data.frame(matrix(nrow = length(MOIs),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
for(m in 1:length(MOIs)){
cols.w.morphs[m,] <- grepl(MOIs[m], names(stat_table), ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[-(bad.morphs == MOIs[i])]
}
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,
ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
}
cols.of.interest
}
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,
ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
}
}
b
sum(grepl(bad.morphs[b], cols.of.interest,ignore.case = T))
bad.morphs[b]
bad.morphs
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[-(bad.morphs == MOIs[i])]
}
bad.morphs
MOIs
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
MOIs[i]
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[bad.morphs != MOIs[i]]
}
bad.morphs
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
}
}
cols.of.interest
MOIs <- c("Rascon", "Pachon", "Tinaja")
cols.w.morphs <- data.frame(matrix(nrow = length(MOIs),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
for(m in 1:length(MOIs)){
cols.w.morphs[m,] <- grepl(MOIs[m], names(stat_table), ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(MOIs)){
bad.morphs <- bad.morphs[bad.morphs != MOIs[i]]
}
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
}
}
cols.of.interest
cols.of.interest[grepl("Fst",
cols.of.interest,
ignore.case = T)]
cols.of.interest <- cols.of.interest[grepl("Fst",
cols.of.interest,
ignore.case = T)]
cols.of.interest[i]
cols.of.interest[1]
names(stat_table) == cols.of.interest[1]
num_pool <- c()
for(i in 1:length(cols.of.interest)){
num_pool <- append(num_pool,
stat_table(,names(stat_table) == cols.of.interest[i]))
}
for(i in 1:length(cols.of.interest)){
num_pool <- append(num_pool,
stat_table[,names(stat_table) == cols.of.interest[i]])
}
length(stat_table[,names(stat_table) == cols.of.interest[i]])
which.min(num_pool)
num_pool[which.min(num_pool)]
num_pool[which.max(num_pool)]
library(shiny); runApp('CaveCrawler.R')
list(minimum,maximum)
minimum <- num_pool[which.min(num_pool)]
maximum <- num_pool[which.max(num_pool)]
list(minimum,maximum)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
# This function finds the minimum and maximum values for a population-specific
# statistic in a statistical table
MinMax <- function(mm_pops, mm_stat, stat_table){
# Create matrix to store all columns which house the morphs-of-interest
cols.w.morphs <- data.frame(matrix(nrow = length(mm_pops),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(mm_pops)){
cols.w.morphs[m,] <- grepl(mm_pops[m], names(stat_table),
ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
# Of the columns of stat_table which house at least one morph-of-interest,
# exclude the columns which have morphs which are NOT morphs of interest
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(mm_pops)){
bad.morphs <- bad.morphs[bad.morphs != mm_pops[i]]
}
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
}
}
# Find columns-of-interest which house stat-of-interest
cols.of.interest <- cols.of.interest[grepl(mm_stat,
cols.of.interest,
ignore.case = T)]
# Combine columns-of-interest into a single vector of numbers
num_pool <- c()
for(i in 1:length(cols.of.interest)){
num_pool <- append(num_pool,
stat_table[,names(stat_table) == cols.of.interest[i]])
}
# Output the minimum and maximum values in that vector
minimum <- num_pool[which.min(num_pool)]
maximum <- num_pool[which.max(num_pool)]
return(list(minimum,maximum))
}
MinMax(c("Pachon","Rascon","Tinaja"), "Fst", stat_table)
class("string")
class("vector")
library(shiny); runApp('CaveCrawler.R')
grepl(mm_pops[m], names(stat_table),
ignore.case = T)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
?round
round(0.983,2)
runApp('CaveCrawler.R')
