GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
GeneToGO <- GeneToGO[,c(3:8,10)]
# 12-05
# Remove irrelevant columns from GeneToGo
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
GeneToGO <- GeneToGO[,c(3:9,11)]
GeneToGO <- GeneToGO[!is.na(GeneToGO$Gene.ontology.IDs),]
GeneToGO <- GeneToGO[!duplicated(GeneToGO$Ensembl_GeneID),]
# 12-05
# Remove irrelevant columns from GeneToGo
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
GeneToGO <- GeneToGO[,c(3:9,11)]
test <- GeneToGO[duplicated(GeneToGO$Ensembl_GeneID),]
test
View(test)
# 12-05
# Remove irrelevant columns from GeneToGo
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
GeneToGO <- GeneToGO[,c(4:9,11)]
test
test <- GeneToGO[duplicated(GeneToGO$Ensembl_GeneID),]
# 12-05
# Remove irrelevant columns from GeneToGo
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
# 12-05
# Remove irrelevant columns from GeneToGo
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
GeneToGO <- GeneToGO[,c(4,6:9,11)]
test <- GeneToGO[duplicated(GeneToGO$Ensembl_GeneID),]
GeneToGO <- GeneToGO[!duplicated(GeneToGO),]
write.csv("data/AMexGOTerms.csv", row.names = F)
write.csv(GeneToGO, "data/AMexGOTerms.csv", row.names = F)
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
View(HS11)
View(HS13)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
MasterGO <- cbind(GO_classes$Namespace, GO_classes$GO_ID)
colnames(MasterGO) <- c(names(GO_classes)[2], names(GO_classes)[1])
View(MasterGO)
View(MasterGO)
MasterGO <- data.frame(Namespace = GO_classes$Namespace,
GO_ID = GO_classes$GO_ID,
GO_Term = rep(NA, nrow(GO_classes)))
View(MasterGO)
# If the GO ID is present in the GO IDs and names, add the corresponding GO term
for(i in 1:length(MasterGO)){
print(i)
if(MasterGO$GO_ID[i] %in% GoIDToNames$GO.ID){
MasterGO$GO_Term[i] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == MasterGO$GO_ID[i]]
}else{
next
}
}
MasterGO <- data.frame(Namespace = GO_classes$Namespace,
GO_ID = GO_classes$GO_ID,
GO_Term = rep(NA, nrow(GO_classes)))
# If the GO ID is present in the GO IDs and names, add the corresponding GO term
for(i in 1:nrow(MasterGO)){
print(i)
if(MasterGO$GO_ID[i] %in% GoIDToNames$GO.ID){
MasterGO$GO_Term[i] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == MasterGO$GO_ID[i]]
}else{
next
}
}
View(MasterGO)
write.csv(MasterGO,"data/MasterGO.csv")
MasterGO <- read.csv("data/MasterGO.csv", fill = T)
GoIDToNames <- read.table("data/GOIDs_and_Names.txt", fill = T, sep = "\t", header = T)
# Concatenate all GO-containing files into a single file
GO_classes <- read.table("data/GOID_Namespaces.txt", fill = T, sep = "\t", header = T)
GoIDToNames <- read.table("data/GOIDs_and_Names.txt", fill = T, sep = "\t", header = T)
# This section of the script...
# 1. Identifies all GO term cells containing information from multiple lines
messed_cells <- GoIDToNames$GO.Term[grepl("\n", GoIDToNames$GO.Term)]
# 2. Splices the cells into strings based on newline characters and adds strings
#    to a vector
newline_strings <- c()
sites.of.errors <- c()
for(c in 1:length(messed_cells)){
newline_strings <- append(newline_strings, str_split(string = messed_cells[c],
pattern = "\n"))
sites.of.errors <- append(sites.of.errors,
which(GoIDToNames$GO.Term == messed_cells[c]))
}
library(stringr)
for(c in 1:length(messed_cells)){
newline_strings <- append(newline_strings, str_split(string = messed_cells[c],
pattern = "\n"))
sites.of.errors <- append(sites.of.errors,
which(GoIDToNames$GO.Term == messed_cells[c]))
}
error.replacements <- c()
for(i in 1:length(newline_strings)){
# 3. Records sites at which an erroneous GO term must be replaced with a
#    corrected GO term
error.replacements <- append(error.replacements, newline_strings[[i]][1])
newline_strings[[i]] <- newline_strings[[i]][-1]
# 4. Splices the strings of the vector into substrings based on \t and adds
#    substring pairs as columns to a temporary dataframe
temp_df <- data.frame(matrix(ncol = 2, nrow = 1))
new_rows <- str_split(string = newline_strings[[i]], pattern = "\t")
for(r in 1:length(new_rows)){
temp_df <- rbind(temp_df, new_rows[[r]])
}
temp_df <- temp_df[-1,]
names(temp_df) <- names(GoIDToNames)
# 5. Inserts the temporary data frame into the master data frame
GoIDToNames <- rbind(GoIDToNames, temp_df)
next
}
# 6. Replaces the erroneous GO term with a corrected GO term
GoIDToNames$GO.Term[sites.of.errors] <- error.replacements
MasterGO <- data.frame(Namespace = GO_classes$Namespace,
GO_ID = GO_classes$GO_ID,
GO_Term = rep(NA, nrow(GO_classes)))
# If the GO ID is present in the GO IDs and names, add the corresponding GO term
for(i in 1:nrow(MasterGO)){
print(i)
if(MasterGO$GO_ID[i] %in% GoIDToNames$GO.ID){
MasterGO$GO_Term[i] <- GoIDToNames$GO.Term[GoIDToNames$GO.ID == MasterGO$GO_ID[i]]
}else{
next
}
}
write.csv(MasterGO,"data/MasterGO.csv")
# In this function, the user inputs GO ID(s) or a phrase and the function
# outputs the class, lower-level GO IDs, and GO term associated with each
# relevant GO ID
GOInfo <- function(GO_input, MasterGO, UpperLower){
# Initialize a vector in which to store GO IDs
GO_ID_vec <- c()
# Initialize an empty dataframe to output in the event of an error
error.df <- data.frame(matrix(nrow = 1, ncol = 4))
names(error.df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
# Initialize a vector in which to output warnings/errors
wrnings <- c("Notes: ")
# Find whether input is comma-separated list of GO IDs, single GO ID, or
# phrase and fill GO_ID_vec with appropriate GO IDs based on answer
if((grepl(", ", GO_input))){
# If input is a comma-separated list of GO IDs, parse string and add
# each GO ID to the vector of GO IDs
temp_GO_ID_vec <- str_split(string = GO_input, pattern = ", ")[[1]]
# Check to ensure that at least one of the inputted IDs is a real GO ID
for(i in 1:length(temp_GO_ID_vec)){
if(temp_GO_ID_vec[i] %in% MasterGO$GO_ID){
GO_ID_vec <- append(GO_ID_vec, temp_GO_ID_vec[i])
next
}else{
wrnings <- append(wrnings, paste(c("Input ",temp_GO_ID_vec[i],
" is not a GO ID."),
collapse = ""))
next
}
}
# If NONE of the inputs are real GO IDs, output an error
if(is.null(GO_ID_vec)){
return(list("ERROR: None of the inputs in the comma-separated list are GO IDs",
error.df))
}
}else if(!(grepl(", ", GO_input)) & (GO_input %in% MasterGO$GO_ID)){
# If input is a single GO ID, add it to the vector of GO IDs
GO_ID_vec <- GO_input
}else if(!(grepl(", ", GO_input)) & !(GO_input %in% MasterGO$GO_ID)){
# If input is a phrase, find all GO terms associated with that phrase
if(sum(grepl(GO_input, MasterGO$GO_Term, ignore.case = T)) != 0){
GO_ID_vec <- MasterGO$GO_ID[grepl(GO_input, MasterGO$GO_Term,
ignore.case = T)]
# If NO GO terms are associated with the phrase, output an error
}else{
return(list(paste(c("ERROR: Input ", GO_input,
" is neither a GO ID nor a phrase associated with any recorded GO IDs"),
collapse = ""), error.df))
}
}
# Create a dataframe with the GO terms, namespaces, and lower-level GO IDs
# associated with all input GO IDs
GO_df <- data.frame(matrix(nrow = length(GO_ID_vec), ncol = 4))
names(GO_df) <- c("GO ID",
"GO Term",
"Namespace",
"All Nested GO IDs")
for(GO in 1:length(GO_ID_vec)){
# Output GO ID
GO_df$`GO ID`[GO] <- GO_ID_vec[GO]
# Output GO term, if present
if(GO_ID_vec[GO] %in% MasterGO$GO_ID){
GO_df$`GO Term`[GO] <- MasterGO$GO_Term[MasterGO$GO_ID == GO_ID_vec[GO]]
}else{
GO_df$`GO Term`[GO] <- "Not applicable"
}
# Output class of GO ID
if(GO_ID_vec[GO] %in% MasterGO$GO_ID){
GO_df$Namespace[GO] <- MasterGO$Namespace[MasterGO$GO_ID == GO_ID_vec[GO]]
}else{
GO_df$Namespace[GO] <- "Not applicable"
}
# Output all lower-level GO IDs associated with current GO ID
# First, add the current GO ID to a vector
lower_GOs <- GO_ID_vec[GO]
for(g in 1:length(lower_GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(lower_GOs[g] %in% UpperLower$Upper){
lower_GOs <- append(lower_GOs,
UpperLower$Lower[UpperLower$Upper == lower_GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column,
# skip it
}else{
next
}
}
# Remove the first GO ID from the vector of lower GO IDs, as this is the
# original GO ID
lower_GOs <- lower_GOs[-1]
if(length(lower_GOs) != 0){
GO_df$`All Nested GO IDs`[GO] <- paste(lower_GOs, collapse = "; ")
}else{
GO_df$`All Nested GO IDs`[GO] <- "No lower-level GO IDs"
}
}
# Return data frame and warnings, if applicable
return(list(wrnings, GO_df))
}
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
GOInfo("GO:0036359", MasterGO, UpperLower)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
View(GeneToGO)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
MasterGO <- read.csv("data/MasterGO.csv", fill = T, row.names = F)
View(MasterGO)
in_type = "Statistic Value"
UL = "bottom"
stat = "Fst"
thresh = 0.05
pops = c("Rascon","Pachon")
# Create 2 vectors of the indices corresponding to each population or pop
# pair's statistic values
indices <- c()
pop_strings <- c()
# Create vector into which warnings will be stored for later output
wrnings <- c("Notes:\n")
# Check if statistic of interest makes comparisons between TWO populations
if((stat == "Fst") | (stat == "Dxy")){
# Tell the program that a two-population statistic was entered so the
# program outputs the specified number of genes for EACH population
stat_type = "Two Pop"
# Find all population pairs
two_pops <- combn(pops,2)
# If so, iterate through each combination of pops and output the indices
# and string version of the population pair
for(pair in 1:ncol(two_pops)){
# If pops is a matrix, read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "index" equal to the column housing this statistic
val <- which(grepl(two_pops[1, pair], names(stat_table))
& grepl(two_pops[2, pair], names(stat_table))
& grepl(stat, names(stat_table)))
# If statistic for populations-of-interest is not present, return error
if(length(val) == 0){
wrnings <- append(wrnings, (paste(c("Statistic",stat,
"is not present for the populations",two_pops[1, pair],"and",
two_pops[2, pair], "\n"),collapse = " ")))
# If these populations-of-interest are the only pops which were
# inputted, return a warning
if(ncol(two_pops) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 8))
names(null.df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Outlier (if Fst)",
"Publication Name"
)
return(list(paste(c("Statistic ",stat,
" is not present for the populations ",
two_pops[1, pair]," and ",
two_pops[2, pair]),collapse = ""),
null.df))
}
}else{
# Create a row to add to the indices dataframe
temp_str <- paste(c(two_pops[1, pair],"-",two_pops[2, pair]), collapse = "")
pop_strings <- append(pop_strings,temp_str)
indices <- append(indices,val)
}
# If pops is NOT a matrix, return an error
}
}else if((stat == "TajimasD") | (stat == "Pi")){
# Tell the program that a one-population statistic was entered so the
# program outputs the specified number of genes across ALL populations
stat_type = "One Pop"
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
val <- which(grepl(pops[p], names(stat_table))
& grepl(stat, names(stat_table)))
# If statistic for populations-of-interest is not present, return a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, (paste(c("Statistic",stat,
"is not present for the population",
pops[p],"\n"),collapse = " ")))
}else{
pop_strings <- append(pop_strings,pops[p])
indices <- append(indices,val)
}
}
}else{
return("ERROR: Invalid statistic name")
}
indices
# Initialize vectors of gene names, populations, statistic values, outlier
# status, and publication names
genes <- c()
DF_pops <- c()
stat_vals <- c()
Fst_outlier <- c()
pub_names <- c()
# Check if statistic value or gene count was entered
# If value was entered...
if(in_type == "Statistic Value"){
# Check whether top or bottom proportion was requested
# If higher proportion was requested, iterate through each index
if(UL == "top"){
for(i in 1:length(indices)){
# First, remove all NA values for this index
stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# For each index, collect all genes, scaffolds, populations, values,
# and publication names whose stat values fall above the entered value
genes <- append(genes,stat_table$Gene_Name[
stat_table[,indices[i]] >= thresh])
DF_pops <- append(DF_pops,rep(pop_strings[i],
length(stat_table$Gene_Name[
stat_table[,indices[i]] >= thresh])))
stat_vals <- append(stat_vals,stat_table[
stat_table[,indices[i]] >= thresh,indices[i]])
Fst_outlier <- append(Fst_outlier,stat_table$Fst_Outliers[
stat_table[,indices[i]] >= thresh])
pub_names <- append(pub_names,stat_table$Publication[
stat_table[,indices[i]] >= thresh])
}
# If lower tail was requested, iterate through each index
}else if(UL == "bottom"){
for(i in 1:length(indices)){
# First, remove all NA values for this index
stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# For each index, collect all genes, populations, and statistic values
# whose values fall in lowest tail
genes <- append(genes,stat_table$Gene_Name[
stat_table[,indices[i]] <= thresh])
DF_pops <- append(DF_pops,rep(pop_strings[i],
length(stat_table$Gene_Name[
stat_table[,indices[i]] <= thresh])))
stat_vals <- append(stat_vals,stat_table[
stat_table[,indices[i]] <= thresh,indices[i]])
Fst_outlier <- append(Fst_outlier,stat_table$Fst_Outliers[
stat_table[,indices[i]] <= thresh])
pub_names <- append(pub_names,stat_table$Publication[
stat_table[,indices[i]] <= thresh])
}
}
# If count was entered...
}else if(in_type == "Gene Count"){
# Check whether top or bottom proportion was requested
# If top count was requested, iterate through each index
if(UL == "top"){
# Check if statistic is a one or a two population statistic
# If statistic is a two-population statistic, output the top N genes for ALL
# possible population pairs
if(stat_type == "Two Pop"){
# For each index...
for(i in 1:length(indices)){
# First, remove all NA values for this index
stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# Collect positions of top N genes for the current index
top_genes <- order(
stat_table[,indices[i]], decreasing = T)[1:thresh]
# Collect the genes with the highest values, as well as the associated
# populations and values
genes <- append(genes,stat_table$Gene_Name[top_genes])
DF_pops <- append(DF_pops,rep(pop_strings[i],length(top_genes)))
stat_vals <- append(stat_vals,stat_table[top_genes,indices[i]])
Fst_outlier <- append(Fst_outlier,stat_table$Fst_Outliers[top_genes])
pub_names <- append(pub_names,stat_table$Publication[
top_genes])
}
# If statistic is a one-population statistic, output collect the N genes
# with the HIGHEST stat value, regardless of pop
}else if(stat_type == "One Pop"){
# Collect stat values for ALL indices into a 3 vectors: row
# in one column, population name in another,and stat value in the other
all_stats <- c()
all_pops <- c()
all_genes <- c()
all_outliers <- c()
all_pubs <- c()
for(i in 1:length(indices)){
# First, remove all NA values for this index
stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
all_stats <- append(all_stats, stat_table[,indices[i]])
all_pops <- append(all_pops,rep(pop_strings[i],
length(stat_table[,indices[i]])))
all_genes <- append(all_genes, stat_table$Gene_Name[top_genes])
all_outliers <- append(all_outliers,stat_table$Fst_Outliers)
all_pubs <- append(all_genes, stat_table$Publication)
}
# Organize vectors into a dataframe
temp_df <- data.frame(
all_stats,
all_pops,
all_genes,
all_outliers,
all_pubs
)
# Retrieve the parallel indices for the N highest genes
par_indices <- order(temp_df$all_stats, decreasing = T)[1:thresh]
# Retrieve the gene names, population names, stat values, and
# publication names
genes <- append(genes,temp_df$all_genes[par_indices])
DF_pops <- append(DF_pops,temp_df$all_pops[par_indices])
stat_vals <- append(stat_vals,temp_df$all_stats[par_indices])
Fst_outlier <- append(Fst_outlier,temp_df$all_outliers[par_indices])
pub_names <- append(pub_names,temp_df$all_pubs[par_indices])
}
# If lower proportion was requested, iterate through each index
}else if(UL == "bottom"){
# Check if statistic is a one or a two population statistic
# If statistic is a two-population statistic, output the bottom N genes for ALL
# possible population pairs
if(stat_type == "Two Pop"){
# For each index...
for(i in 1:length(indices)){
# First, remove all NA values for this index
stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# Collect positions of bottom N genes for the current index
bottom_genes <- order(stat_table[,indices[i]], decreasing = F)[1:thresh]
# Collect the genes with the highest values, as well as the
# associated populations, values, and publications
genes <- append(genes,stat_table$Gene_Name[bottom_genes])
DF_pops <- append(DF_pops,rep(pop_strings[i],length(bottom_genes)))
stat_vals <- append(stat_vals,stat_table[bottom_genes,indices[i]])
Fst_outlier <- append(Fst_outlier,stat_table$Fst_Outliers[bottom_genes])
pub_names <- append(pub_names,stat_table$Publication[bottom_genes])
}
# If statistic is a one-population statistic, output collect the N genes
# with the HIGHEST stat value, regardless of pop
}else if(stat_type == "One Pop"){
# Collect stat values for ALL indices into a 3 vectors: row
# in one column, population name in another,and stat value in the other
all_stats <- c()
all_pops <- c()
all_genes <- c()
all_outliers <- c()
all_pubs <- c()
for(i in 1:length(indices)){
# First, remove all NA values for this index
stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
all_stats <- append(all_stats, stat_table[,indices[i]])
all_pops <- append(all_pops,rep(pop_strings[i],
length(stat_table[,indices[i]])))
all_genes <- append(all_genes, stat_table$Gene_Name)
all_outliers <- append(all_outliers, stat_table$Fst_Outliers)
all_pubs <- append(all_genes, stat_table$Publication)
}
# Organize vectors into a dataframe
temp_df <- data.frame(
all_stats,
all_pops,
all_genes,
all_outliers,
all_pubs
)
# Retreat the parallel indeices for the N highest genes
par_indices <- order(temp_df$all_stats, decreasing = F)[1:thresh]
# Retrieve the gene names, population names
genes <- append(genes,temp_df$all_genes[par_indices])
DF_pops <- append(DF_pops,temp_df$all_pops[par_indices])
stat_vals <- append(stat_vals,temp_df$all_stats[par_indices])
Fst_outlier <- append(Fst_outlier,temp_df$all_outliers[par_indices])
pub_names <- append(pub_names,temp_df$all_pubs[par_indices])
}
}
}
stat_vals
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
