}
}
# If GO data was requested...
if(GOBool){
# Check if this gene ID is present in the position table
if(geneIDs[i] %in% GeneToGO$Ensembl_GeneID){
# If so, output the gene ID's GO info to the final dataframe
finalGO$`Gene ID`[i] <- geneIDs[i]
finalGO$`Gene name`[i] <- GeneToGO$Gene.names[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Gene Ontology IDs`[i] <- GeneToGO$Gene.ontology.IDs[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Biological Process`[i] <- GeneToGO$Gene.ontology..biological.process.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Cellular Component`[i] <- GeneToGO$Gene.ontology..cellular.component.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Molecular Function`[i] <- GeneToGO$Gene.ontology..molecular.function.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$Publication[i] <- "7"
}else{
# If not, output all NAs at the corresponding row in the dataframe so the
# length of the dataframe stays consistent. Remove these rows later
finalGO[i,] <- rep(NA, ncol(finalGO))
# Output a warning saying that GO data is not present for this
# ID
warn <- append(warn, paste(c("GO data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
}
# Once you have each of the dataframes, remove all NA rows from each dataframe
# which is supposed to have and output, then output all 4 dataframes AND
# warnings as a list
if(posBool){
finalPos <- finalPos[!is.na(finalPos$`Gene ID`),]
}
if(transcBool){
finalTransc <- finalTransc[!is.na(finalTransc$`Gene ID`),]
}
if(popgenBool){
finalPopgen <- finalPopgen[!is.na(finalPopgen$`Gene ID`),]
}
if(GOBool){
finalGO <- finalGO[!is.na(finalGO$`Gene ID`),]
}
return(list(finalPos,finalTransc,finalPopgen,finalGO,warn))
}
GeneSearch(input = "bfsp2, cryba1l1",
posBool = F,
transcBool = F,
popgenBool = T,
GOBool = F,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
# Test on a phrase one bool at a time
GeneSearch(input = "pHaKiNin",
posBool = T,
transcBool = F,
popgenBool = F,
GOBool = F,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
GeneSearch(input = "pHaKiNin",
posBool = F,
transcBool = T,
popgenBool = F,
GOBool = F,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
GeneSearch(input = "pHaKiNin",
posBool = F,
transcBool = F,
popgenBool = T,
GOBool = F,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
GeneSearch(input = "pHaKiNin",
posBool = F,
transcBool = F,
popgenBool = F,
GOBool = T,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
GeneSearch <- function(input, posBool, transcBool, popgenBool, GOBool,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO){
# Initialize warnings
warn <- c("Notes: ")
# Output warnings if data was not requested so the user does not get confused
# by the lack of output
if(posBool == F){
warn <- append(warn, "Position table is blank because position information was not requested.")
}
if(transcBool == F){
warn <- append(warn, "Transcription table is blank because transcription information was not requested.")
}
if(popgenBool == F){
warn <- append(warn, "Population genetics table is blank because Population genetics information was not requested.")
}
if(GOBool == F){
warn <- append(warn, "GO table is blank because GO information was not requested.")
}
# Define a comma
comma <- ", "
# Define a vector in which to store all inputs
input_vec <- c()
# Check if comma occurs in input string
if(grepl(comma, input)){
# If so, split the input string and add each individual input to the input
# vector
input_vec <- str_split(input, pattern = comma)[[1]]
}else{
# If not, add the whole string to the input vector
input_vec <- input
}
# Define a vector in which to store gene IDs
geneIDs <- c()
# Iterate through each entry in vector of inputs to find the IDs corresponding
# to these inputs
for(i in 1:length(input_vec)){
# Check if current entry is a gene ID
if(grepl("ENSAMXG", input_vec[i])){
# If current entry IS a gene ID, simply append to vector of IDs
geneIDs <- append(geneIDs, input_vec[i])
}else{
# If current entry is NOT a gene ID, convert to lowercase and grep all
# lower-case gene name and gene info columns for this string.
searchTerm <- tolower(input_vec[i])
tempIDs <- c()
# grep every gene name in position table (use grep instead of %in% for
# partial gene name matching)
for(g in 1:nrow(position_table)){
if(grepl(searchTerm, tolower(position_table$Gene_Name[g]))){
tempIDs <- append(tempIDs, position_table$Gene_ID[g])
}
}
# statistic table
for(s in 1:nrow(stat_table)){
# If current entry is part of the gene name, description, OR GO terms,
# add the ID to the vector of IDs
if((grepl(searchTerm, tolower(stat_table$Gene_Name[s]))) |
(grepl(searchTerm, tolower(stat_table$Gene_Description[s]))) |
(grepl(searchTerm, tolower(stat_table$GO_Terms[s])))){
tempIDs <- append(tempIDs, stat_table$Stable_Gene_ID[s])
}
}
# transcription tables
for(t in 1:nrow(morph1.morph2)){
# If current entry is part of the gene name or study-specific details,
# add the ID to the vector of IDs
if((grepl(searchTerm, tolower(morph1.morph2$Gene_name[t]))) |
(grepl(searchTerm, tolower(morph1.morph2$study_specific_gene_details[t])))){
tempIDs <- append(tempIDs, morph1.morph2$Gene_stable_ID[t])
}
}
for(t in 1:nrow(condition_control)){
# If current entry is part of the gene name, gene description, or Ensembl
# description, add the ID to the vector of IDs
if((grepl(searchTerm, tolower(condition_control$Gene_name[t]))) |
(grepl(searchTerm, tolower(condition_control$Gene_description[t]))) |
(grepl(searchTerm, tolower(condition_control$Ensembl_Family_Description[t])))){
tempIDs <- append(tempIDs, condition_control$Gene_stable_ID[t])
}
}
# GO table
for(go in 1:nrow(GeneToGO)){
# If current entry is found in the gene name or any of the GO info, add
# the ID corresponding to this information to the vector of gene IDs
if((grepl(searchTerm, tolower(GeneToGO$Gene.names[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology..biological.process.[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology..cellular.component.[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology..molecular.function.[go]))) |
(grepl(searchTerm, tolower(GeneToGO$Gene.ontology.IDs[go])))){
tempIDs <- append(tempIDs, GeneToGO$Ensembl_GeneID[go])
}
}
# If no info is found for the current ID, append a warning and skip
if(length(tempIDs) == 0){
warn <- append(warn, paste(c("No genes found corresponding to the input",
input_vec[i]), collapse = " "))
}else{
# Once ID(s) corresponding to this entry are found, remove duplicate/NA IDs,
# append the IDs to the gene ID vector, then move to the next entry
geneIDs <- append(geneIDs, tempIDs[!duplicated(tempIDs) &
!grepl("NA", tempIDs) &
!is.na(tempIDs)])
next
}
}
}
# Initialize final dataframes in which to store data corresponding to ALL gene
# IDs
finalPos <- data.frame(matrix(nrow = length(geneIDs), ncol = 6))
finalGO <- data.frame(matrix(nrow = length(geneIDs), ncol = 7))
# Do not give row names for transcription or popgen data because there could
# be multiple rows per gene
finalTransc <- data.frame(matrix(ncol = 9))
finalPopgen <- data.frame(matrix(ncol = 8))
names(finalPos) <- c("Gene ID",
"Gene name",
"Scaffold",
"Start Locus",
"End Locus",
"Publication")
names(finalTransc) <- c("Gene ID",
"Gene name",
"Gene description",
"Study-specific information",
"Comparison",
"logFC",
"p-value",
"Condition",
"Publication")
names(finalPopgen) <- c("Gene ID",
"Gene name",
"Gene description",
"Statistic Type",
"Population(s)",
"Statistic Value",
"Study-specific information",
"Publication")
names(finalGO) <- c("Gene ID",
"Gene name",
"Gene Ontology IDs",
"Biological Process",
"Cellular Component",
"Molecular Function",
"Publication")
# If no info was found for ANY of the entries, output an ERROR
if(length(geneIDs) == 0){
warn <- paste(c("Error: No genes can be described by any of these inputs:",
input), collapse = "\n")
return(list(finalPos, finalTransc, finalPopgen, tempGO, warn))
}
# Iterate through each gene ID in the vector of gene IDs
for(i in 1:length(geneIDs)){
# If position data was requested...
if(posBool){
# Check if this gene ID is present in the position table
if(geneIDs[i] %in% position_table$Gene_ID){
# If so, output the gene ID's info to the temp dataframe and bind this
# temp dataframe
finalPos$`Gene ID`[i] <- position_table$Gene_ID[
position_table$Gene_ID == geneIDs[i]]
finalPos$`Gene name`[i] <- position_table$Gene_Name[
position_table$Gene_ID == geneIDs[i]]
finalPos$Scaffold[i] <- position_table$Scaffold[
position_table$Gene_ID == geneIDs[i]]
finalPos$`Start Locus`[i] <- position_table$Start_Locus[
position_table$Gene_ID == geneIDs[i]]
finalPos$`End Locus`[i] <- position_table$End_Locus[
position_table$Gene_ID == geneIDs[i]]
finalPos$Publication[i] <- "6"
}else{
# If not, output all NAs at the corresponding row in the dataframe so the
# length of the dataframe stays consistent. Remove these rows later
finalPos[i,] <- rep(NA, ncol(finalPos))
# Output a warning saying that position data is not present for this
# ID
warn <- append(warn, paste(c("Positional data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
# If transcription data was requested...
if(transcBool){
# Start with the assumption that there is no transcription data present
# for this gene
transcAbsent <- T
if(geneIDs[i] %in% morph1.morph2$Gene_stable_ID){
# If there is transcription data for morph-morph comparisons, add this
# data to a temporary dataframe and bind the temp dataframe to the final
transcAbsent <- F
tempTransc <- data.frame(matrix(
nrow = sum(morph1.morph2$Gene_stable_ID == geneIDs[i]), ncol = 9))
names(tempTransc) <- c("Gene ID","Gene name","Gene description",
"Study-specific information","Comparison",
"logFC","p-value","Condition","Publication")
# Since there may be multiple rows corresponding to a single gene ID,
# output as many gene IDs as there are copies
tempTransc$`Gene ID` <- morph1.morph2$Gene_stable_ID[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Gene name` <- morph1.morph2$Gene_name[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Gene description` <- "Not available for this study"
tempTransc$`Study-specific information` <- morph1.morph2$study_specific_gene_details[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$Comparison <- morph1.morph2$Comparison[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$logFC <- morph1.morph2$logFC[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$`p-value` <- morph1.morph2$PValue[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$Condition <- morph1.morph2$Condition[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$Publication <- morph1.morph2$Publication[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
finalTransc <- rbind(finalTransc, tempTransc)
}
if(geneIDs[i] %in% condition_control$Gene_stable_ID){
# If there is transcription data for condition-control comparisons, add
# this data to a temporary dataframe and bind the temp dataframe to the
# final
transcAbsent <- F
tempTransc <- data.frame(matrix(
nrow = sum(condition_control$Gene_stable_ID == geneIDs[i]), ncol = 9))
names(tempTransc) <- c("Gene ID","Gene name","Gene description",
"Study-specific information","Comparison",
"logFC","p-value","Condition","Publication")
# Since there may be multiple rows corresponding to a single gene ID,
# output as many gene IDs as there are copies
tempTransc$`Gene ID` <- condition_control$Gene_stable_ID[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Gene name` <- condition_control$Gene_name[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Gene description` <- condition_control$Gene_description[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Study-specific information` <- "Not available for this study"
tempTransc$Comparison <- condition_control$Comparison[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$logFC <- condition_control$logFC[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`p-value` <- condition_control$PValue[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$Condition <- condition_control$Condition[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$Publication <- condition_control$Publication[
condition_control$Gene_stable_ID == geneIDs[i]
]
finalTransc <- rbind(finalTransc, tempTransc)
}
# If there is no transcription data for this gene in either class, output
# a warning
if(transcAbsent){
warn <- append(warn, paste(c("Transcriptional data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
# If popgen data was requested...
if(popgenBool){
if(geneIDs[i] %in% stat_table$Stable_Gene_ID){
# Create a subset of the stat_table dataframe
subsetPopgen <- subset(stat_table, subset = Stable_Gene_ID == geneIDs[i])
# For each row in the subset dataframe, search each STATISTIC column and
# dissect the column information into a row of the temporary dataframe
for(r in 1:nrow(subsetPopgen)){
for(c in 4:28){
# Ensure the current statistic value is not simply NA
if(!is.na(subsetPopgen[r,c])){
# Create a temporary dataframe with just a single row
tempPopgen <- data.frame(matrix(nrow = 1, ncol = 8))
names(tempPopgen) <- c("Gene ID","Gene name","Gene description",
"Statistic Type","Population(s)","Statistic Value",
"Study-specific information","Publication")
tempPopgen$`Gene ID`[1] <- geneIDs[i]
tempPopgen$`Gene name`[1] <- subsetPopgen$Gene_Name[r]
tempPopgen$`Gene description`[1] <- subsetPopgen$Gene_Description[r]
names_pops <- str_split(names(subsetPopgen)[c], "_")[[1]]
tempPopgen$`Statistic Type`[1] <- names_pops[1]
tempPopgen$`Population(s)`[1] <- names_pops[2]
tempPopgen$`Statistic Value`[1] <- subsetPopgen[r,c]
# Only output study specific information if the statistic is Fst
if((names_pops[1] == "Fst") & !is.na(subsetPopgen$Fst_Outliers[r])){
tempPopgen$`Study-specific information`[1] <-
paste(c("Fst Outlier Populations: ",
subsetPopgen$Fst_Outliers[r]), collapse = "")
}else{
tempPopgen$`Study-specific information`[1] <- "Not available for this study"
}
tempPopgen$Publication[1] <- subsetPopgen$Publication[r]
finalPopgen <- rbind(finalPopgen, tempPopgen)
}
}
}
# Bind the temporary dataframe to the final
}else{
# If the gene ID is not present in the statistical data, output a warning
warn <- append(warn, paste(c("Population genetics data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
# If GO data was requested...
if(GOBool){
# Check if this gene ID is present in the position table
if(geneIDs[i] %in% GeneToGO$Ensembl_GeneID){
# If so, output the gene ID's GO info to the final dataframe
finalGO$`Gene ID`[i] <- geneIDs[i]
finalGO$`Gene name`[i] <- GeneToGO$Gene.names[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Gene Ontology IDs`[i] <- GeneToGO$Gene.ontology.IDs[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Biological Process`[i] <- GeneToGO$Gene.ontology..biological.process.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Cellular Component`[i] <- GeneToGO$Gene.ontology..cellular.component.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Molecular Function`[i] <- GeneToGO$Gene.ontology..molecular.function.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$Publication[i] <- "7"
}else{
# If not, output all NAs at the corresponding row in the dataframe so the
# length of the dataframe stays consistent. Remove these rows later
finalGO[i,] <- rep(NA, ncol(finalGO))
# Output a warning saying that GO data is not present for this
# ID
warn <- append(warn, paste(c("GO data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
}
# Once you have each of the dataframes, remove all NA rows from each dataframe
# which is supposed to have and output, then output all 4 dataframes AND
# warnings as a list
if(posBool){
finalPos <- finalPos[!is.na(finalPos$`Gene ID`),]
}
if(transcBool){
finalTransc <- finalTransc[!is.na(finalTransc$`Gene ID`),]
}
if(popgenBool){
finalPopgen <- finalPopgen[!is.na(finalPopgen$`Gene ID`),]
}
if(GOBool){
finalGO <- finalGO[!is.na(finalGO$`Gene ID`),]
}
return(list(finalPos,finalTransc,finalPopgen,finalGO,warn))
}
# Test on a single gnee ID with all bools specified
GeneSearch(input = "GO:0006099",
posBool = T,
transcBool = T,
popgenBool = T,
GOBool = T,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
# 12-06
# Re-designed GeneSearch to take up fewer lines, be case-insensitive, output no
# duplicates, and more easily integrate new data
library(stringr)
library(dplyr)
# Test on a single gnee ID with all bools specified
GeneSearch(input = "GO:0006099",
posBool = T,
transcBool = T,
popgenBool = T,
GOBool = T,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
PB <- T
TB <- T
PGB <- T
GOB <- T
x <- GeneSearch(input = "bfsp2",
posBool = PB,
transcBool = TB,
popgenBool = PGB,
GOBool = GOB,
position_table = position_table,
morph1.morph2 = morph1.morph2,
condition_control = condition_control,
stat_table = stat_table,
GeneToGO = GeneToGO)
library(stringr)
library(dplyr)
x <- GeneSearch(input = "bfsp2",
posBool = PB,
transcBool = TB,
popgenBool = PGB,
GOBool = GOB,
position_table = position_table,
morph1.morph2 = morph1.morph2,
condition_control = condition_control,
stat_table = stat_table,
GeneToGO = GeneToGO)
unformattedPopgen <- x[[3]]
unformattedPopgen
reformattedPopgen <- data.frame(
unformattedPopgen[,1:5],
format(unformattedPopgen[,6], digits = 5),
unformattedPopgen[,7:8]
)
names(reformattedPopgen) <- names(unformattedPopgen)
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
