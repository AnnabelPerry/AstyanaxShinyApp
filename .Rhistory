next
}else{
indices <- append(indices, indx)
next
}
}
# Check if statistic of interest makes comparisons between ONE population
}else if((stat == "TajimasD") | (stat == "Pi")){
# Tell the program that a one-population statistic was entered so the
# program outputs the specified number of genes across ALL populations
stat_type = "One Pop"
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
indx <- append(indices, which(grepl(pops[p], names(stat_table))
& grepl(stat, names(stat_table))))
# If statistic for populations-of-interest is not present, return note
if(length(indx) == 0){
wrnings <- append(wrnings, paste(c("Statistic",stat,
"is not present for the population",pops[p]),
collapse = " "))
next
}else{
indices <- append(indices, indx)
next
}
}
}
# Remove all rows where stat-of-interest is NA
filt_table <- stat_table[!is.na(stat_table[,indices]),]
# Create dataframe with appropriate stat values
temp = c()
indices
# Create dataframe with appropriate stat values
temp = c()
for(i in 1:length(indices)){
temp <- append(temp, filt_table[,indices[i]])
}
temp
# Rename df statistics column with specific statistic name so you can
# reference the statistic values in the plotting function
names(df)[1] <- stat
View(df)
# Coerce statistics into a one column dataframe so you can use
# ShadedDensity()
df <- as.data.frame(temp)
View(df)
# Rename df statistics column with specific statistic name so you can
# reference the statistic values in the plotting function
names(df)[1] <- stat
# Create density plot. Title must be different depending on whether you
# have one or two populations
pop_string = ""
# Create a string to be used in the title of the density plot
pop_string = ""
for(p in 1:length(pops)){
if(p == 1){
pop_string <- pops[p]
}else if((p != length(pops)) & (p != 1)){
pop_string <- paste(c(pop_string, ", ", pops[p]), collapse = "")
}else if(p == length(pops)){
pop_string <- paste(c(pop_string, pops[p]), collapse = ", and ")
}
}
pop_string
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
output_plot <- ShadedDensity(frame = df,
xvar = c(df[,2:length(df)]),
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
}else{
output_plot <- ShadedDensity(frame = df,
xvar = stat,
threshold = thresh,
title = paste(c(stat, " values for ", pop_string),
collapse = ""),
tail = t)
}
library(WVPlots)
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
output_plot <- ShadedDensity(frame = df,
xvar = c(df[,2:length(df)]),
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
}else{
output_plot <- ShadedDensity(frame = df,
xvar = stat,
threshold = thresh,
title = paste(c(stat, " values for ", pop_string),
collapse = ""),
tail = t)
}
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
output_plot <- ShadedDensity(frame = df,
xvar = stat,
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
}else{
output_plot <- ShadedDensity(frame = df,
xvar = stat,
threshold = thresh,
title = paste(c(stat, " values for ", pop_string),
collapse = ""),
tail = t)
}
output_plot <- ShadedDensity(frame = df,
xvar = Statistic_Values,
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
# Rename df statistics column so you can reference the statistic values i
# in the plotting function
names(df)[1] <- "Statistic_Values"
View(df)
output_plot <- ShadedDensity(frame = df,
xvar = Statistic_Values,
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
output_plot <- ShadedDensity(frame = df,
xvar = "Statistic_Values",
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
sum(is.na(df))
!is.na(filt_table)
# Create dataframe with values of stat-of-interest for every single pop-of
# -interest
temp = c()
for(i in 1:length(indices)){
temp <- append(temp, stat_table[,indices[i]])
}
# Coerce statistics into a one column dataframe so you can use
# ShadedDensity()
filt_table <- as.data.frame(temp)
!is.na(filt_table)
# Remove missing vlaues so plotting function will work
filt_table <- filt_table[!is.na(filt_table)]
sum(is.na(filt_table))
# Pick a direction to shade in based on whether "top" or "bottom" was
# specified
if(UL == "top"){
t = "right"
}else if(UL == "bottom"){
t = "left"
}
# Create a string to be used in the title of the density plot
pop_string = ""
for(p in 1:length(pops)){
if(p == 1){
pop_string <- pops[p]
}else if((p != length(pops)) & (p != 1)){
pop_string <- paste(c(pop_string, ", ", pops[p]), collapse = "")
}else if(p == length(pops)){
pop_string <- paste(c(pop_string, pops[p]), collapse = ", and ")
}
}
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
output_plot <- ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
}else{
output_plot <- ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = paste(c(stat, " values for ", pop_string),
collapse = ""),
tail = t)
}
ShadedDensity(frame = filt_table,
xvar = Statistic_Values,
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
# Create dataframe with values of stat-of-interest for every single pop-of
# -interest
temp = c()
for(i in 1:length(indices)){
temp <- append(temp, stat_table[,indices[i]])
}
# Remove missing vlaues so plotting function will work
temp <- temp[!is.na(temp)]
# Coerce statistics into a one column dataframe so you can use
# ShadedDensity()
filt_table <- as.data.frame(temp)
# Rename df statistics column so you can reference the statistic values i
# in the plotting function
names(filt_table)[1] <- "Statistic_Values"
sum(is.na(filt_table))
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = paste(c("Pairwise", stat, " values for ",
pop_string), collapse = ""),
tail = t)
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = paste(c(stat, " values for ", pop_string),
collapse = ""),
tail = t)
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
plot_title <- paste(c("Pairwise", stat, " values for ",
pop_string), collapse = "")
}else{
plot_title <- paste(c(stat, " values for ", pop_string),
collapse = "")
}
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
plot_title <- paste(c("Pairwise", stat, " values for ",
pop_string), collapse = "")
}else{
plot_title <- paste(c(stat, " values for ", pop_string),
collapse = "")
}
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
plot_title <- paste(c("Pairwise", stat, " values for ",pop_string), collapse = "")
}else{
plot_title <- paste(c(stat, " values for ", pop_string),collapse = "")
}
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t)
StatDistPlot <- function(stat, UL, thresh, stat_table, pops){
# EDIT: Check if threshold is within appropriate range for statistic-of-interest. If
# not, return an error.
# Initialize vector into which notes will be stored
wrnings <- c("Notes: ")
# Create an error plot to be returned if an error occurs
error_plot <- plot(x = c(.95, .955,  .975,  1, 1.025, 1.05,   1.07,  1.075, 0.99, 1.035),
y = c( 1, 1.5, 1.75, 2, 2,    1.75,  1.5,   1,    3.5,    3.5), pch = 16, axes = F,
ylab = "",
xlab = "Whoops! Something went wrong. See errors")
# Initialize vector of indices
indices <- c()
# Check if statistic of interest makes comparisons between TWO populations
if((stat == "Fst") | (stat == "Dxy")){
# Tell the program that a two-population statistic was entered so the
# program outputs the specified number of genes for EACH population
stat_type = "Two Pop"
if(length(pops) == 1){
return(list("ERROR: Only one population supplied for a two-population statistic
\n Either 'pops' is not a vector or 'pops' has only one entry.\n",error_plot))
}
# Find all population pairs
two_pops <- combn(pops,2)
# If so, iterate through each combination of pops and output the indices
# and string version of the population pair
for(pair in 1:ncol(two_pops)){
# Read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "indx" equal to the column housing this statistic
indx <- which(grepl(two_pops[1, pair], names(stat_table))
& grepl(two_pops[2, pair], names(stat_table))
& grepl(stat, names(stat_table)))
# If statistic for populations-of-interest is not present, return error
if(length(indx) == 0){
wrnings <- append(wrnings, paste(c("Statistic",stat,
"is not present for the populations",two_pops[1, pair],"and",
two_pops[2, pair]),collapse = " "))
next
}else{
indices <- append(indices, indx)
next
}
}
# Check if statistic of interest makes comparisons between ONE population
}else if((stat == "TajimasD") | (stat == "Pi")){
# Tell the program that a one-population statistic was entered so the
# program outputs the specified number of genes across ALL populations
stat_type = "One Pop"
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
indx <- append(indices, which(grepl(pops[p], names(stat_table))
& grepl(stat, names(stat_table))))
# If statistic for populations-of-interest is not present, return note
if(length(indx) == 0){
wrnings <- append(wrnings, paste(c("Statistic",stat,
"is not present for the population",pops[p]),
collapse = " "))
next
}else{
indices <- append(indices, indx)
next
}
}
}
# Create dataframe with values of stat-of-interest for every single pop-of
# -interest
temp = c()
for(i in 1:length(indices)){
temp <- append(temp, stat_table[,indices[i]])
}
# Remove missing vlaues so plotting function will work
temp <- temp[!is.na(temp)]
# Coerce statistics into a one column dataframe so you can use
# ShadedDensity()
filt_table <- as.data.frame(temp)
# Rename df statistics column so you can reference the statistic values i
# in the plotting function
names(filt_table)[1] <- "Statistic_Values"
# Pick a direction to shade in based on whether "top" or "bottom" was
# specified
if(UL == "top"){
t = "right"
}else if(UL == "bottom"){
t = "left"
}
# Create a string to be used in the title of the density plot
pop_string = ""
for(p in 1:length(pops)){
if(p == 1){
pop_string <- pops[p]
}else if((p != length(pops)) & (p != 1)){
pop_string <- paste(c(pop_string, ", ", pops[p]), collapse = "")
}else if(p == length(pops)){
pop_string <- paste(c(pop_string, pops[p]), collapse = ", and ")
}
}
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type = "Two Pop"){
plot_title <- paste(c("Pairwise", stat, " values for ",pop_string),
collapse = "")
}else{
plot_title <- paste(c(stat, " values for ", pop_string),collapse = "")
}
output_plot <- ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t)
return(list(wrnings, output_plot))
}
StatDistPlot <- function(stat, UL, thresh, stat_table, pops){
# EDIT: Check if threshold is within appropriate range for statistic-of-interest. If
# not, return an error.
# Initialize vector into which notes will be stored
wrnings <- c("Notes: ")
# Create an error plot to be returned if an error occurs
error_plot <- plot(x = c(.95, .955,  .975,  1, 1.025, 1.05,   1.07,  1.075, 0.99, 1.035),
y = c( 1, 1.5, 1.75, 2, 2,    1.75,  1.5,   1,    3.5,    3.5), pch = 16, axes = F,
ylab = "",
xlab = "Whoops! Something went wrong. See errors")
# Initialize vector of indices
indices <- c()
# Check if statistic of interest makes comparisons between TWO populations
if((stat == "Fst") | (stat == "Dxy")){
# Tell the program that a two-population statistic was entered so the
# program outputs the specified number of genes for EACH population
stat_type = "Two Pop"
if(length(pops) == 1){
return(list("ERROR: Only one population supplied for a two-population statistic
\n Either 'pops' is not a vector or 'pops' has only one entry.\n",error_plot))
}
# Find all population pairs
two_pops <- combn(pops,2)
# If so, iterate through each combination of pops and output the indices
# and string version of the population pair
for(pair in 1:ncol(two_pops)){
# Read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "indx" equal to the column housing this statistic
indx <- which(grepl(two_pops[1, pair], names(stat_table))
& grepl(two_pops[2, pair], names(stat_table))
& grepl(stat, names(stat_table)))
# If statistic for populations-of-interest is not present, return error
if(length(indx) == 0){
wrnings <- append(wrnings, paste(c("Statistic",stat,
"is not present for the populations",two_pops[1, pair],"and",
two_pops[2, pair]),collapse = " "))
next
}else{
indices <- append(indices, indx)
next
}
}
# Check if statistic of interest makes comparisons between ONE population
}else if((stat == "TajimasD") | (stat == "Pi")){
# Tell the program that a one-population statistic was entered so the
# program outputs the specified number of genes across ALL populations
stat_type = "One Pop"
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
indx <- append(indices, which(grepl(pops[p], names(stat_table))
& grepl(stat, names(stat_table))))
# If statistic for populations-of-interest is not present, return note
if(length(indx) == 0){
wrnings <- append(wrnings, paste(c("Statistic",stat,
"is not present for the population",pops[p]),
collapse = " "))
next
}else{
indices <- append(indices, indx)
next
}
}
}
# Create dataframe with values of stat-of-interest for every single pop-of
# -interest
temp = c()
for(i in 1:length(indices)){
temp <- append(temp, stat_table[,indices[i]])
}
# Remove missing vlaues so plotting function will work
temp <- temp[!is.na(temp)]
# Coerce statistics into a one column dataframe so you can use
# ShadedDensity()
filt_table <- as.data.frame(temp)
# Rename df statistics column so you can reference the statistic values i
# in the plotting function
names(filt_table)[1] <- "Statistic_Values"
# Pick a direction to shade in based on whether "top" or "bottom" was
# specified
if(UL == "top"){
t = "right"
}else if(UL == "bottom"){
t = "left"
}
# Create a string to be used in the title of the density plot
pop_string = ""
for(p in 1:length(pops)){
if(p == 1){
pop_string <- pops[p]
}else if((p != length(pops)) & (p != 1)){
pop_string <- paste(c(pop_string, ", ", pops[p]), collapse = "")
}else if(p == length(pops)){
pop_string <- paste(c(pop_string, pops[p]), collapse = ", and ")
}
}
# Create density plot. Title must be different depending on whether you
# have one or two populations
if(stat_type == "Two Pop"){
plot_title <- paste(c("Pairwise", stat, " values for ",pop_string),
collapse = "")
}else{
plot_title <- paste(c(stat, " values for ", pop_string),collapse = "")
}
output_plot <- ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t)
return(list(wrnings, output_plot))
}
StatDistPlot(stat = "Fst",UL = "top",thresh = 0.9,stat_table,pops = c("Molino", "Pachon", "Rascon", "Rio Choy", "Tinaja"))
x <- StatDistPlot(stat = "Fst",UL = "top",thresh = 0.9,stat_table,pops = c("Molino", "Pachon", "Rascon", "Rio Choy", "Tinaja"))
x[[2]]
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
?ShadedDensity
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t,
shading = "hotpink")
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t,
shading = "darkpink")
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t,
shading = "pink")
ShadedDensity(frame = filt_table,
xvar = "Statistic_Values",
threshold = thresh,
title = plot_title,
tail = t,
shading = "maroon")
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
