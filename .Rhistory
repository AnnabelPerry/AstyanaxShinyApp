(geneGOs$Gene[g] %in% stat_table$Gene_Name) &
(geneGOs$Gene[g] %in% position_table$Gene_Name)
# Find the number of copies of the current gene in the statistic
# table
copies <- length(stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
copies
stat_table$Gene_Name == geneGOs$Gene[g]
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])]
stat_pop_combos$Col[i]
i
i = 1
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])]
# Find the number of copies of the current gene in the statistic
# table
copies <- length(stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
copies
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])]
# Output the current gene as many times as there are copies
Gene <- append(Gene, rep(geneGOs$Gene[g], copies))
position_table$Scaffold[position_table$Gene_Name == geneGOs$Gene[g]]
geneGOs
rep(geneGOs$Gene[g], copies)
Gene <- c()
Scaffold <- c()
Start_Position <- c()
End_Position <- c()
GO_IDs <- c()
Statistic_Type <- c()
Population <- c()
Statistic_Value <- c()
Pub_Name <- c()
for(i in 1:nrow(stat_pop_combos)){
for(g in 1:length(geneGOs$Gene)){
# Check if current gene is in stat AND position table
# If so...
if((geneGOs$Gene[g] %in% stat_table$Gene_Name) &
(geneGOs$Gene[g] %in% position_table$Gene_Name)){
# Find the number of copies of the current gene in the statistic
# table
copies <- length(stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the current gene as many times as there are copies
Gene <- append(Gene, rep(geneGOs$Gene[g], copies))
# Output scaffold of current gene as many times as there are copies
Scaffold <- append(Scaffold,
rep(position_table$Scaffold[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output starting position of the current gene as many times as
# there are copies of the gene
Start_Position <- append(Start_Position,
rep(position_table$Start_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output the ending position of the current gene as many times as
# there are copies of the gene
End_Position <- append(End_Position,
rep(position_table$End_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output ALL GO terms associated with the current gene as many times
# as there are copies of the gene
GO_IDs <- append(GO_IDs,
rep(
paste(geneGOs$GO_ID[geneGOs$Gene == geneGOs$Gene[g]], collapse = "; "),
copies))
# Output the current statistic type as many times as there are copies
# of the gene
Statistic_Type <- append(Statistic_Type,
rep(stat_pop_combos$Stat_Type[i],
copies))
# Output the population(s) which correspond to the current column,
# and output as many times as there are copies of the gene.
Population <- append(Population, rep(stat_pop_combos$Pop[i],
copies))
# Output the statistic value. Will automatically output value for
# each copy of the gene.
Statistic_Value <- append(Statistic_Value,
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the publication from which the statistic was obtained
Pub_Name <- append(Pub_Name, stat_table$Publication_Name[which(
stat_table$Gene_Name == geneGOs$Gene[g]
)])
# If not, skip the gene
}else{
next
}
}
}
Scaffold[1:14]
Gene[1:14]
!duplicated(position_table)
# Remove duplicates so multiple rows with the same values are not outputted
position_table <- position_table[!duplicated(position_table),]
Gene <- c()
Scaffold <- c()
Start_Position <- c()
End_Position <- c()
GO_IDs <- c()
Statistic_Type <- c()
Population <- c()
Statistic_Value <- c()
Pub_Name <- c()
for(i in 1:nrow(stat_pop_combos)){
for(g in 1:length(geneGOs$Gene)){
# Check if current gene is in stat AND position table
# If so...
if((geneGOs$Gene[g] %in% stat_table$Gene_Name) &
(geneGOs$Gene[g] %in% position_table$Gene_Name)){
# Find the number of copies of the current gene in the statistic
# table
copies <- length(stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the current gene as many times as there are copies
Gene <- append(Gene, rep(geneGOs$Gene[g], copies))
# Output scaffold of current gene as many times as there are copies
Scaffold <- append(Scaffold,
rep(position_table$Scaffold[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output starting position of the current gene as many times as
# there are copies of the gene
Start_Position <- append(Start_Position,
rep(position_table$Start_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output the ending position of the current gene as many times as
# there are copies of the gene
End_Position <- append(End_Position,
rep(position_table$End_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output ALL GO terms associated with the current gene as many times
# as there are copies of the gene
GO_IDs <- append(GO_IDs,
rep(
paste(geneGOs$GO_ID[geneGOs$Gene == geneGOs$Gene[g]], collapse = "; "),
copies))
# Output the current statistic type as many times as there are copies
# of the gene
Statistic_Type <- append(Statistic_Type,
rep(stat_pop_combos$Stat_Type[i],
copies))
# Output the population(s) which correspond to the current column,
# and output as many times as there are copies of the gene.
Population <- append(Population, rep(stat_pop_combos$Pop[i],
copies))
# Output the statistic value. Will automatically output value for
# each copy of the gene.
Statistic_Value <- append(Statistic_Value,
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the publication from which the statistic was obtained
Pub_Name <- append(Pub_Name, stat_table$Publication_Name[which(
stat_table$Gene_Name == geneGOs$Gene[g]
)])
# If not, skip the gene
}else{
next
}
}
}
output_df <- data.frame(Gene,
Scaffold,
Start_Position,
End_Position,
GO_IDs,
Statistic_Type,
Population,
Statistic_Value,
Pub_Name
)
# Remove duplicates so multiple rows with the same values are not outputted
position_table <- position_table[!duplicated(position_table$Gene_Name),]
# Remove duplicates so multiple rows with the same values are not outputted
position_table$Gene_Name <- to.lower(position_table$Gene_Name)
# Remove duplicates so multiple rows with the same values are not outputted
position_table$Gene_Name <- tolower(position_table$Gene_Name)
position_table <- position_table[!duplicated(position_table$Gene_Name),]
StatByChrTable <- function(GOTerm, GeneToGo, GoIDToNames, UpperLower,
stat_vec, position_table, stat_table, pops){
# Initialize vector for all GO terms of interest
GOs <- c()
# Initialize vector in which to store warnings
wrnings <- c("Notes: ")
# Check if user inputted a word/phrase or a GO ID. If the user inputted a
# word/phrase, find the name(s) which contains that word/phrase and set the GO
# vector equal to the corresponding GO IDs.
if(!(GOTerm %in% GoIDToNames$GO.ID)){
if(length(GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]) != 0){
GOs <- GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]
# If the input is not found in the GO terms but does have a comma,
# output both as GO IDs and check whether they are valid GO IDs
}else if((length(GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]) == 0)
& (grepl(", ", GOTerm, ignore.case = T))){
GOs <- str_split(GOTerm, ", ")[[1]]
# If the input is not found in the GO terms and does not have a comma,
# return an error
}else if((length(GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]) == 0)
& !(grepl(", ", GOTerm, ignore.case = T))){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: Input is neither a valid GO ID nor a valid phrase",
null.df))
}
# If user inputted a GO ID, add that ID
}else if(GOTerm %in% GoIDToNames$GO.ID){
GOs <- GOTerm
}
# Find all GO terms which are LOWER than the GO terms in the GO vector.
# First, loop through each GO ID in the vector-of-GOs. As more GO IDs, are
# added to the vector, the number of remaining iterations will increase.
for(g in 1:length(GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(GOs[g] %in% UpperLower$Upper){
GOs <- append(GOs, UpperLower$Lower[UpperLower$Upper == GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column, skip it
}else{
next
}
}
# Find all genes associated with the current GO IDs and add to vector of genes
gene_vec <- c()
found_GOs <- c()
for(g in 1:length(GOs)){
found = F
# If the GO term appears in the data frame of names AND the corresponding gene
# occurs in the statistics vector, add the GO term and gene name
for(i in 1:length(GeneToGO$Gene.ontology.IDs)){
if(grepl(GOs[g], GeneToGO$Gene.ontology.IDs[i])){
found = T
}else{
next
}
}
if(found){
gene_vec <- append(gene_vec, GeneToGO$Gene.names[grepl(GOs[g],
GeneToGO$Gene.ontology.IDs)])
found_GOs <- append(found_GOs, rep(GOs[g],
length(GeneToGO$Gene.names[grepl(GOs[g],
GeneToGO$Gene.ontology.IDs)])))
# If the GO term does NOT appear in the dataframe of names, skip it
}else{
next
}
}
geneGOs <- data.frame(
Gene = gene_vec,
GO_ID = found_GOs
)
geneGOs <- geneGOs[!duplicated(geneGOs), ]
# Extract all possible combinations of populations from populations of interest
if(("Fst" %in% stat_vec) | ("Dxy" %in% stat_vec)){
all_pops <- combn(pops,2)
two_pop <- T
}else{
two_pop <- F
}
# Create a temporary dataframe for all possible combinations of statistic
# types, columns, and the populations to which they correspond
stat_pop_combos <- data.frame(matrix(ncol = 3))
colnames(stat_pop_combos) <- c("Stat_Type", "Pop", "Col")
for(s in 1:length(stat_vec)){
# Check if statistic of interest makes comparisons between TWO populations
if((stat_vec[s] == "Fst") | (stat_vec[s] == "Dxy")){
# Check if all_pops was created
if(two_pop){
# If so, iterate through each combination and output stat value for that
# combination
for(pair in 1:ncol(all_pops)){
# If pops is a matrix, read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "index" equal to the column housing this statistic
val <- which(grepl(all_pops[1, pair], names(stat_table))
& grepl(all_pops[2, pair], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, add a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the populations ",
all_pops[1, pair]," and ",
all_pops[2, pair], " | "),collapse = ""))
# If these populations-of-interest are the only pops which were
# inputted, return a warning
if(ncol(all_pops) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list(paste(c("Statistic ",stat_vec[s],
" is not present for the populations ",
all_pops[1, pair]," and ",
all_pops[2, pair]),collapse = "")),
null.df)
}
}else{
# Create a row to add to the indices data frame
temp_str <- paste(c(all_pops[1, pair],"-",all_pops[2, pair]),
collapse = "")
temp_vec <- c(stat_vec[s],temp_str,val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
# If pops is NOT a matrix, return an error
}
}else{
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list(paste(c("ERROR: Only one population, ", pops,
", supplied for the two-population statistic ",
stat_vec[s], "."),
collapse = ""), null.df))
# Check if statistic of interest makes comparisons between ONE population
}
}else if((stat_vec[s] == "TajimasD") | (stat_vec[s] == "Pi")){
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
val <- which(grepl(pops[p], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, return a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the population ",
pops[p], " | "), collapse = ""))
}else{
# Create a row to add to the indices dataframe
temp_vec <- c(stat_vec[s],pops[p],val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
}
}
}
# If NONE of the populations-of-interest had values for the statistics-of-
# interest, output an error
if(nrow(stat_pop_combos) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: None of the input statistics are present for any of the input populations",
null.df))
}
# If dataframe was valid, remove first row (as this is all NAs from)
# initialization
stat_pop_combos <- stat_pop_combos[-1,]
# For each GO Term in the vector of GO Terms-of-interest, find...
# 1. All gene names which occur in the positions table AND in the statistics
#    table
# 2. The scaffolds of those genes
# 3. The starting positions of those genes
# 4. The ending positions of those genes
# 5. The GO terms associated with those genes
# 6. Each of the 4 statistic types
# 7. Each of the populations/population combinations
# 8. Each of the statistical values
# 9. Publication from which the statistic value was derived
# For each statistic-population pair, iterate through each gene and find the
# statistic value, scaffold, starting position, and ending position and
# output to a dataframe
Gene <- c()
Scaffold <- c()
Start_Position <- c()
End_Position <- c()
GO_IDs <- c()
Statistic_Type <- c()
Population <- c()
Statistic_Value <- c()
Pub_Name <- c()
for(i in 1:nrow(stat_pop_combos)){
for(g in 1:length(geneGOs$Gene)){
# Check if current gene is in stat AND position table
# If so...
if((geneGOs$Gene[g] %in% stat_table$Gene_Name) &
(geneGOs$Gene[g] %in% position_table$Gene_Name)){
# Find the number of copies of the current gene in the statistic
# table
copies <- length(stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the current gene as many times as there are copies
Gene <- append(Gene, rep(geneGOs$Gene[g], copies))
# Output scaffold of current gene as many times as there are copies
Scaffold <- append(Scaffold,
rep(position_table$Scaffold[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output starting position of the current gene as many times as
# there are copies of the gene
Start_Position <- append(Start_Position,
rep(position_table$Start_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output the ending position of the current gene as many times as
# there are copies of the gene
End_Position <- append(End_Position,
rep(position_table$End_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output ALL GO terms associated with the current gene as many times
# as there are copies of the gene
GO_IDs <- append(GO_IDs,
rep(
paste(geneGOs$GO_ID[geneGOs$Gene == geneGOs$Gene[g]], collapse = "; "),
copies))
# Output the current statistic type as many times as there are copies
# of the gene
Statistic_Type <- append(Statistic_Type,
rep(stat_pop_combos$Stat_Type[i],
copies))
# Output the population(s) which correspond to the current column,
# and output as many times as there are copies of the gene.
Population <- append(Population, rep(stat_pop_combos$Pop[i],
copies))
# Output the statistic value. Will automatically output value for
# each copy of the gene.
Statistic_Value <- append(Statistic_Value,
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the publication from which the statistic was obtained
Pub_Name <- append(Pub_Name, stat_table$Publication_Name[which(
stat_table$Gene_Name == geneGOs$Gene[g]
)])
# If not, skip the gene
}else{
next
}
}
}
output_df <- data.frame(Gene,
Scaffold,
Start_Position,
End_Position,
GO_IDs,
Statistic_Type,
Population,
Statistic_Value,
Pub_Name
)
return(list(wrnings, output_df))
}
test_table <- StatByChrTable(GOTerm = "GO:0016021", GeneToGo, GoIDToNames, UpperLower,
stat_vec = c("Fst","Dxy"), position_table, stat_table, pops = c("Chica1","Chica2","Pachon","Rascon","Tinaja","Molino","Rio Choy"))[[2]]
View(test_table)
View(stat_table)
test_table <- StatByChrTable(GOTerm = "GO:0016021", GeneToGo, GoIDToNames, UpperLower,
stat_vec = c("Fst","Dxy"), position_table, stat_table, pops = c("Chica1","Chica2","Pachon","Rascon","Tinaja","Molino","Rio Choy"))[[2]]
View(test_table)
StatByChrGraph(test_table)
StatByChrGraph(test_table,c("Dxy","Fst"))
library(shinyWidgets)
library(shiny)
library(ggplot2)
library(plotly)
library(WVPlots)
library(stringr)
library(tibble)
library(gridExtra)
library(dplyr)
StatByChrGraph(test_table,c("Dxy","Fst"))
View(stat_table)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
?downloadHandler
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
