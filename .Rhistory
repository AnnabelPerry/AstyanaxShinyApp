stat_vec[s], "."),
collapse = ""), null.df))
# Check if statistic of interest makes comparisons between ONE population
}
}else if((stat_vec[s] == "TajimasD") | (stat_vec[s] == "Pi")){
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
val <- which(grepl(pops[p], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, return a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the population ",
pops[p], " | "), collapse = ""))
}else{
# Create a row to add to the indices dataframe
temp_vec <- c(stat_vec[s],pops[p],val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
}
}
}
# If NONE of the populations-of-interest had values for the statistics-of-
# interest, output an error
if(nrow(stat_pop_combos) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: None of the input statistics are present for any of the input populations",
null.df))
}
# If dataframe was valid, remove first row (as this is all NAs from)
# initialization
stat_pop_combos <- stat_pop_combos[-1,]
# For each GO Term in the vector of GO Terms-of-interest, find...
# 1. All gene names which occur in the positions table AND in the statistics
#    table
# 2. The scaffolds of those genes
# 3. The starting positions of those genes
# 4. The ending positions of those genes
# 5. The GO terms associated with those genes
# 6. Each of the 4 statistic types
# 7. Each of the populations/population combinations
# 8. Each of the statistical values
# 9. Publication from which the statistic value was derived
# For each statistic-population pair, iterate through each gene and find the
# statistic value, scaffold, starting position, and ending position and
# output to a dataframe
Gene <- c()
Scaffold <- c()
Start_Position <- c()
End_Position <- c()
GO_IDs <- c()
Statistic_Type <- c()
Population <- c()
Statistic_Value <- c()
Pub_Name <- c()
for(i in 1:nrow(stat_pop_combos)){
for(g in 1:length(geneGOs$Gene)){
# Check if current gene is in stat AND position table
# If so...
if((geneGOs$Gene[g] %in% stat_table$Gene_Name) &
(geneGOs$Gene[g] %in% position_table$Gene_Name)){
# Find the number of copies of the current gene in the statistic
# table
copies <- length(stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the current gene as many times as there are copies
Gene <- append(Gene, rep(geneGOs$Gene[g], copies))
# Output scaffold of current gene as many times as there are copies
Scaffold <- append(Scaffold,
rep(position_table$Scaffold[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output starting position of the current gene as many times as
# there are copies of the gene
Start_Position <- append(Start_Position,
rep(position_table$Start_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output the ending position of the current gene as many times as
# there are copies of the gene
End_Position <- append(End_Position,
rep(position_table$End_Locus[position_table$Gene_Name == geneGOs$Gene[g]],
copies))
# Output ALL GO terms associated with the current gene as many times
# as there are copies of the gene
GO_IDs <- append(GO_IDs,
rep(
paste(geneGOs$GO_ID[geneGOs$Gene == geneGOs$Gene[g]], collapse = "; "),
copies))
# Output the current statistic type as many times as there are copies
# of the gene
Statistic_Type <- append(Statistic_Type,
rep(stat_pop_combos$Stat_Type[i],
copies))
# Output the population(s) which correspond to the current column,
# and output as many times as there are copies of the gene.
Population <- append(Population, rep(stat_pop_combos$Pop[i],
copies))
# Output the statistic value. Will automatically output value for
# each copy of the gene.
Statistic_Value <- append(Statistic_Value,
stat_table[stat_table$Gene_Name == geneGOs$Gene[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the publication from which the statistic was obtained
Pub_Name <- append(Pub_Name, stat_table$Publication_Name[which(
stat_table$Gene_Name == geneGOs$Gene[g]
)])
# If not, skip the gene
}else{
next
}
}
}
output_df <- data.frame(Gene,
Scaffold,
Start_Position,
End_Position,
GO_IDs,
Statistic_Type,
Population,
Statistic_Value,
Pub_Name
)
return(list(wrnings, output_df))
}
StatByChrTable(GOTerm = "GO:0004930", GeneToGo, GoIDToNames, UpperLower,
stat_vec = "Fst", position_table, stat_table, pops = c("Chica1","Molino"))
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
View(condition_control)
morph1 = "Pachon"
morph2 = "Control"
condition = "Sleep deprivation"
direction = "Downregulated"
percent = 50
TranscTable(morph1 = "Pachon",
morph2 = "Control",
condition = "Sleep deprivation",
direction = "Downregulated",
percent = 50, GOTable = GeneToGO)
test_transc <- TranscTable(morph1 = "Pachon",
morph2 = "Control",
condition = "Sleep deprivation",
direction = "Downregulated",
percent = 50, GOTable = GeneToGO)
View(test_transc)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
TranscTable <- function(morph1, morph2, condition, direction, percent,
GOTable){
# If condition is NOT "Between morph"...
if(condition != "Between morph"){
# Use transcription data of morph-control comparisons
in_table <- condition_control
# Store comparison
comp <- paste(c(morph1, "Control"), collapse = "-")
# If upregulated genes were requested...
if(direction == "Upregulated"){
# Find [percent]% of genes falling on morph(s)-of-interest with HIGHEST
# logFC scores AND p-value < 0.05
# Find all rows-of-interest (ROIs) for morph-of-interest where genes are
# upregulated, condition matches the input specification, and p-value is
# less than 0.05
ROIs <- in_table[(grepl(morph1, in_table$Class) & (in_table$logFC > 0) &
(in_table$Condition == condition) & (in_table$PValue < 0.05)), ]
# Sort candidate rows with highest logFC values on top
ROIs <- ROIs[order(ROIs[,3], decreasing = T),]
# Find the number of rows corresponding to the specified percent
n.rows <- as.integer((percent/100)*nrow(ROIs))
# If downregulated genes were requested...
}else if(direction == "Downregulated"){
# Find [percent]% of genes falling on morph(s)-of-interest with LOWEST
# logFC scores AND p-value < 0.05
# Find all rows-of-interest (ROIs) for morph-of-interest where genes are
# downregulated, condition matches the input specification, and p-value is
# less than 0.05
ROIs <- in_table[(grepl(morph1, in_table$Class) & (in_table$logFC < 0) &
(in_table$Condition == condition) & (in_table$PValue < 0.05)), ]
# Sort candidate rows with LOWEST logFC values on top
ROIs <- ROIs[order(ROIs[,3], decreasing = F),]
# Find the number of rows corresponding to the specified percent
n.rows <- as.integer((percent/100)*nrow(ROIs))
}
# Obtain GO terms for ROIs
GOTerms <- character(length = n.rows)
for(i in 1:n.rows){
if(tolower(ROIs$Gene_name)[i] %in% GeneToGO$Gene.names){
GOTerms[i] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == tolower(ROIs$Gene_name)[i]]
}else{
GOTerms[i] = NA
}
}
# Output gene names, gene stable IDs, GO terms, morph-of-comparison, logFC,
# p-value, Ensembl family information, and publication name to a dataframe
output.df <- data.frame(
tolower(ROIs$Gene_name)[1:n.rows],
ROIs[1:n.rows,1],
GOTerms,
rep(comp, n.rows)[1:n.rows],
ROIs$logFC[1:n.rows],
ROIs$PValue[1:n.rows],
ROIs$Ensembl_Family_Description[1:n.rows],
ROIs$Publication
)
names(output.df) <- c(
"Gene Name",
"Gene Stable ID",
"GO Term(s)",
"Comparison",
"logFC",
"p-value",
"Ensembl Family Description",
"Publication Name"
)
# If condition is "Between morph"...
}else if(condition == "Between morph"){
# Use transcription data for between-morph comparisons
in_table <- morph1.morph2
# Find rows corresponding to morphs of interest
morph1.rows <- in_table[in_table$Class == morph1,]
morph2.rows <- in_table[in_table$Class == morph2,]
# Find names of all genes present for morph1
m1.genes <- morph1.rows$Gene_name[morph1.rows$Gene_name != ""]
# Subtract all morph2 logFC values FROM all same-gene morph1 logFC value
delta_FC <- c()
genes <- c()
G_IDs <- c()
EF_IDs <- c()
for(g in 1:length(m1.genes)){
if(m1.genes[g] %in% morph2.rows$Gene_name){
diff <- morph1.rows$logFC[morph1.rows$Gene_name == m1.genes[g]] -
morph2.rows$logFC[morph2.rows$Gene_name == m1.genes[g]]
delta_FC <- append(delta_FC, diff)
genes <- append(genes, m1.genes[g])
G_IDs <- append(G_IDs, morph1.rows$Gene_stable_ID[
morph1.rows$Gene_name == m1.genes[g]])
EF_IDs <- append(EF_IDs, morph1.rows$Ensembl_Family_Description[
morph1.rows$Gene_name == m1.genes[g]])
# If morph1 and morph2 do NOT have matching genes, skip this gene
}else{
next
}
}
# Create dataframe to easily access the change in log FC values
# corresponding to each gene pair
ROIs <- data.frame(genes,G_IDs,delta_FC,EF_IDs)
# If genes upregulated in morph1 were requested...
if(direction == "Upregulated"){
# Find genes with greatest POSITIVE change in expression between
# morphs
ROIs <- ROIs[order(delta_FC, decreasing = T),]
n.rows <- as.integer((percent/100)*nrow(ROIs))
# If genes downregulated in morph1 were requested...
}else if(direction == "Downregulated"){
# Find indices of rows with greatest NEGATIVE change in expression between
# morphs
ROIs <- ROIs[order(delta_FC, decreasing = F),]
n.rows <- as.integer((percent/100)*nrow(ROIs))
}
# Find GO terms for genes-of-interest
GOTerms <- character(length = n.rows)
for(i in 1:n.rows){
if(tolower(ROIs$genes)[i] %in% GeneToGO$Gene.names){
GOTerms[i] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == tolower(ROIs$genes)[i]]
}else{
GOTerms[i] = NA
}
}
# Output gene names, gene stable IDs, GO terms, direction, delta(logFC),
# and Ensembl family description
output.df <- data.frame(
tolower(ROIs$genes)[1:n.rows],
ROIs$G_IDs[1:n.rows],
GOTerms,
rep(paste(c(direction, " in ", morph1, " vs. ", morph2), collapse = ""),
n.rows),
ROIs$delta_FC[1:n.rows],
ROIs$EF_IDs[1:n.rows]
)
names(output.df) <- c(
"Gene Name",
"Gene Stable ID",
"GO Term(s)",
"Comparison",
"delta(logFC)",
"Ensembl Family Description"
)
}
return(output.df)
}
test_transc <- TranscTable(morph1 = "Pachon",
morph2 = "Control",
condition = "Sleep deprivation",
direction = "Downregulated",
percent = 50, GOTable = GeneToGO)
morph1 = "Pachon"
morph2 = "Control"
condition = "Sleep deprivation"
direction = "Downregulated"
percent = 50
# If condition is NOT "Between morph"...
if(condition != "Between morph"){
# Use transcription data of morph-control comparisons
in_table <- condition_control
# Store comparison
comp <- paste(c(morph1, "Control"), collapse = "-")
# If upregulated genes were requested...
if(direction == "Upregulated"){
# Find [percent]% of genes falling on morph(s)-of-interest with HIGHEST
# logFC scores AND p-value < 0.05
# Find all rows-of-interest (ROIs) for morph-of-interest where genes are
# upregulated, condition matches the input specification, and p-value is
# less than 0.05
ROIs <- in_table[(grepl(morph1, in_table$Class) & (in_table$logFC > 0) &
(in_table$Condition == condition) & (in_table$PValue < 0.05)), ]
# Sort candidate rows with highest logFC values on top
ROIs <- ROIs[order(ROIs[,3], decreasing = T),]
# Find the number of rows corresponding to the specified percent
n.rows <- as.integer((percent/100)*nrow(ROIs))
# If downregulated genes were requested...
}else if(direction == "Downregulated"){
# Find [percent]% of genes falling on morph(s)-of-interest with LOWEST
# logFC scores AND p-value < 0.05
# Find all rows-of-interest (ROIs) for morph-of-interest where genes are
# downregulated, condition matches the input specification, and p-value is
# less than 0.05
ROIs <- in_table[(grepl(morph1, in_table$Class) & (in_table$logFC < 0) &
(in_table$Condition == condition) & (in_table$PValue < 0.05)), ]
# Sort candidate rows with LOWEST logFC values on top
ROIs <- ROIs[order(ROIs[,3], decreasing = F),]
# Find the number of rows corresponding to the specified percent
n.rows <- as.integer((percent/100)*nrow(ROIs))
}
# Obtain GO terms for ROIs
GOTerms <- character(length = n.rows)
for(i in 1:n.rows){
if(tolower(ROIs$Gene_name)[i] %in% GeneToGO$Gene.names){
GOTerms[i] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == tolower(ROIs$Gene_name)[i]]
}else{
GOTerms[i] = NA
}
}
# Output gene names, gene stable IDs, GO terms, morph-of-comparison, logFC,
# p-value, Ensembl family information, and publication name to a dataframe
output.df <- data.frame(
tolower(ROIs$Gene_name)[1:n.rows],
ROIs[1:n.rows,1],
GOTerms,
rep(comp, n.rows)[1:n.rows],
ROIs$logFC[1:n.rows],
ROIs$PValue[1:n.rows],
ROIs$Ensembl_Family_Description[1:n.rows],
ROIs$Publication
)
names(output.df) <- c(
"Gene Name",
"Gene Stable ID",
"GO Term(s)",
"Comparison",
"logFC",
"p-value",
"Ensembl Family Description",
"Publication Name"
)
# If condition is "Between morph"...
}else if(condition == "Between morph"){
# Use transcription data for between-morph comparisons
in_table <- morph1.morph2
# Find rows corresponding to morphs of interest
morph1.rows <- in_table[in_table$Class == morph1,]
morph2.rows <- in_table[in_table$Class == morph2,]
# Find names of all genes present for morph1
m1.genes <- morph1.rows$Gene_name[morph1.rows$Gene_name != ""]
# Subtract all morph2 logFC values FROM all same-gene morph1 logFC value
delta_FC <- c()
genes <- c()
G_IDs <- c()
EF_IDs <- c()
for(g in 1:length(m1.genes)){
if(m1.genes[g] %in% morph2.rows$Gene_name){
diff <- morph1.rows$logFC[morph1.rows$Gene_name == m1.genes[g]] -
morph2.rows$logFC[morph2.rows$Gene_name == m1.genes[g]]
delta_FC <- append(delta_FC, diff)
genes <- append(genes, m1.genes[g])
G_IDs <- append(G_IDs, morph1.rows$Gene_stable_ID[
morph1.rows$Gene_name == m1.genes[g]])
EF_IDs <- append(EF_IDs, morph1.rows$Ensembl_Family_Description[
morph1.rows$Gene_name == m1.genes[g]])
# If morph1 and morph2 do NOT have matching genes, skip this gene
}else{
next
}
}
# Create dataframe to easily access the change in log FC values
# corresponding to each gene pair
ROIs <- data.frame(genes,G_IDs,delta_FC,EF_IDs)
# If genes upregulated in morph1 were requested...
if(direction == "Upregulated"){
# Find genes with greatest POSITIVE change in expression between
# morphs
ROIs <- ROIs[order(delta_FC, decreasing = T),]
n.rows <- as.integer((percent/100)*nrow(ROIs))
# If genes downregulated in morph1 were requested...
}else if(direction == "Downregulated"){
# Find indices of rows with greatest NEGATIVE change in expression between
# morphs
ROIs <- ROIs[order(delta_FC, decreasing = F),]
n.rows <- as.integer((percent/100)*nrow(ROIs))
}
# Find GO terms for genes-of-interest
GOTerms <- character(length = n.rows)
for(i in 1:n.rows){
if(tolower(ROIs$genes)[i] %in% GeneToGO$Gene.names){
GOTerms[i] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == tolower(ROIs$genes)[i]]
}else{
GOTerms[i] = NA
}
}
# Output gene names, gene stable IDs, GO terms, direction, delta(logFC),
# and Ensembl family description
output.df <- data.frame(
tolower(ROIs$genes)[1:n.rows],
ROIs$G_IDs[1:n.rows],
GOTerms,
rep(paste(c(direction, " in ", morph1, " vs. ", morph2), collapse = ""),
n.rows),
ROIs$delta_FC[1:n.rows],
ROIs$EF_IDs[1:n.rows]
)
names(output.df) <- c(
"Gene Name",
"Gene Stable ID",
"GO Term(s)",
"Comparison",
"delta(logFC)",
"Ensembl Family Description"
)
}
condition != "Between morph"
# Use transcription data of morph-control comparisons
in_table <- condition_control
in_table
# Store comparison
comp <- paste(c(morph1, "Control"), collapse = "-")
comp
direction == "Upregulated"
direction == "Downregulated"
# Find all rows-of-interest (ROIs) for morph-of-interest where genes are
# downregulated, condition matches the input specification, and p-value is
# less than 0.05
ROIs <- in_table[(grepl(morph1, in_table$Class) & (in_table$logFC < 0) &
(in_table$Condition == condition) & (in_table$PValue < 0.05)), ]
ROIs
ROIs
View(ROIs)
# Sort candidate rows with LOWEST logFC values on top
ROIs <- ROIs[order(ROIs[,3], decreasing = F),]
# Find the number of rows corresponding to the specified percent
n.rows <- as.integer((percent/100)*nrow(ROIs))
n.rows
# Obtain GO terms for ROIs
GOTerms <- character(length = n.rows)
for(i in 1:n.rows){
if(tolower(ROIs$Gene_name)[i] %in% GeneToGO$Gene.names){
GOTerms[i] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == tolower(ROIs$Gene_name)[i]]
}else{
GOTerms[i] = NA
}
}
GOTerms
ROIs$Gene_name
# Output gene names, gene stable IDs, GO terms, morph-of-comparison, logFC,
# p-value, Ensembl family information, and publication name to a dataframe
output.df <- data.frame(
tolower(ROIs$Gene_name)[1:n.rows],
ROIs[1:n.rows,1],
GOTerms,
rep(comp, n.rows)[1:n.rows],
ROIs$logFC[1:n.rows],
ROIs$PValue[1:n.rows],
ROIs$Ensembl_Family_Description[1:n.rows],
ROIs$Publication[1:n.rows]
)
names(output.df) <- c(
"Gene Name",
"Gene Stable ID",
"GO Term(s)",
"Comparison",
"logFC",
"p-value",
"Ensembl Family Description",
"Publication Name"
)
View(output.df)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
