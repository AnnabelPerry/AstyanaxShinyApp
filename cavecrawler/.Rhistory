# If gene is present in position table but NOT GO table, output NA for GO
# term but output real scaffold
}else if((genes[g] %in% position_table$Gene_Name) & !(genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = position_table$Scaffold[position_table$Gene_Name == genes[g]]
DF_GOs[g] = "Not applicable"
# If gene is present in GO table but NOT position table, output NA for scaffold
# term but output real GO
}else if(!(genes[g] %in% position_table$Gene_Name) & (genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = "Not applicable"
DF_GOs[g] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == genes[g]][1]
# If gene is present in neither GO nor position tables, output NA for scaff
# and GO
}else if(!(genes[g] %in% position_table$Gene_Name) & !(genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = "Not applicable"
DF_GOs[g] = "Not applicable"
}
}
# Create a dataframe of scaffolds, gene names, GO terms, statistic types, and
# stat values.
prelim_df <- data.frame(
DF_pops,
stat_vals,
scaffs,
genes,
DF_GOs,
pub_names
)
# Sort into a final dataframe
final_df <- data.frame()
# Sort df based on statistic values
# If "top" was checked, sort dataframe in DESCENDING order from top to bottom
# but retain population groups
if(UL == "top"){
# If statistic is a two-population statistic, sort WITHIN populations PRIOR
# to sorting by statistic
if(stat_type == "Two Pop"){
# Create vector in which to store number of genes falling above threshhold
# for each population pair
ranks <- c()
for(i in 1:length(pop_strings)){
rows <- prelim_df[prelim_df$DF_pops == pop_strings[i],]
new_rows <- rows[order(rows$stat_vals, decreasing = T),]
# Collect number of genes found above threshold for THIS population
ranks <- append(ranks, 1:nrow(new_rows))
final_df <- rbind(final_df, new_rows)
}
# Add column which ranks within each population pair
final_df <- add_column(final_df, ranks,.before = T)
# If statistic is a one-population statistic, sort ONLY by statistic value
}else if(stat_type == "One Pop"){
final_df <- prelim_df[order(stat_vals, decreasing = T),]
final_df <- add_column(final_df, 1:nrow(prelim_df),
.before = T)
}
# If "bottom" was checked, sort dataframe in ASCENDING order from top to bottom
# but retain population groups
}else if(UL == "bottom"){
if(stat_type == "Two Pop"){
# Create vector in which to store number of genes falling above threshhold
# for each population pair
ranks <- c()
for(i in 1:length(pop_strings)){
rows <- prelim_df[prelim_df$DF_pops == pop_strings[i],]
new_rows <- rows[order(rows$stat_vals, decreasing = F),]
# Collect number of genes found above threshhold for THIS population
ranks <- append(ranks, 1:nrow(new_rows))
final_df <- rbind(final_df, new_rows)
}
# Add column which ranks within each population pair
final_df <- add_column(final_df, ranks,.before = T)
}else if(stat_type == "One Pop"){
final_df <- prelim_df[order(stat_vals, decreasing = F),]
# Add rank column
final_df <- add_column(final_df, 1:nrow(prelim_df),
.before = T)
}
}
# Rename df stat type and stat value columns with specific statistic's name
names(final_df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Publication"
)
# Output df and warnings
if(is.na(final_df[1,2])){
final_df <- final_df[-1,]
}
list(wrnings, final_df)
thresh
thresh = 10
thresh = 0.9
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
foo <- data.frame(x = c("a","b","c"))
new <- foo[order(foo),]
new <- foo[order(x),]
foo
foo <- data.frame(col_nm = c("a","b","c"))
new <- foo[order(col_nm),]
new <- foo[order(foo$col_nm),]
foo
new
foo <- data.frame(col_nm = c("a","b","c"), col_nm2 = c("x", "y", "z"))
new <- foo[order(foo$col_nm),]
new
new <- foo[order(-foo$col_nm),]
?order
new <- foo[order(foo$col_nm, decreasing = T),]
new
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?order
foo <- data.frame(col1 = c(1e100, 2e50))
foo
foo[order(foo$col1),]
foo <- data.frame(col1 = c(1e100, 2e50, 2e100))
foo[order(foo$col1),]
runApp()
runApp()
?format
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
?order
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
?geom_point
?aes
runApp()
runApp()
runApp()
################################## Load Data ###################################
# Make dataframe of latitudes and longitudes for all morphs
# Citation:
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3282648/pdf/1471-2148-12-9.pdf
Latit_Longit_unedited <- data.frame(
Population = c("Pachon","Yerbaniz","Japonis","Arroyo","Tinaja","Curva","Toro",
"Chica","Molino","Caballo Moro","Subterraneo","Rio Frio",
"Arroyo Sarco", "Chamal","Rio Meco","Rio Tantaon","Rio Florido",
"Rio Tampaon","Nacimiento del Rio Santa Clara",
"San Rafael Los Castros","Rio Subterraneo Valley"),
Latitude = c(22.60,22.20,22.10,22.20,22.08,21.98,21.85,21.85,23.06,22.92,
22.10,22.99,22.02,22.84,22.82,22.37,21.98,21.85,22.50,22.75,22.13
),
Longitude = c(-99.05,-98.97,-98.95,-98.97,-98.95,-98.93,-98.93,-98.93,-99.16,
-99.20,-99.18,-99.15,-99.32,-99.20,-99.31,-98.90,-98.77,-98.94,-98.9,
-99.02,-99.17
),
Morph = c(rep("Cave",10), rep("Surface", 11))
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?geom_point
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
library("ggrepel ")
library("ggrepel")
runApp()
runApp()
runApp()
?geom_label_repel
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
morph1="Pachon"
morph2="Control"
condition="Sleep deprivation"
direction="Above"
tr.stat="logFC"
tr.thresh="9.005"
GOTable=GeneToGO
# If condition is NOT "Between morph"...
if(condition != "Between morph"){
# Use transcription data of morph-control comparisons
in_table <- condition_control
# Set morph2 to control
morph2 <- "Control"
# Set grep pattern to morph1
search_cond <- morph1
# If searching between morphs, set search condition to morphs-of-comparison
}else if(condition == "Between morph"){
# Use transcription data for between-morph comparisons
in_table <- morph1.morph2
# Set grep pattern to comparison
search_cond <- paste(c(morph1, morph2), collapse = "-")
}
# Store comparison for output. Note: "morph2" is control if "Between morph"
# was not entered
comp <- paste(c(morph1, morph2), collapse = "-")
# If genes above threshold were requested...
if(direction == "Above"){
# Find all rows-of-interest (ROIs) for morph(s)-of-interest where logFC is
# above specified value, and condition matches the input specification
if(tr.stat == "logFC"){
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$logFC > tr.thresh) &
(in_table$Condition == condition)), ]
# Sort candidate rows with highest logFC values on top
ROIs <- ROIs[order(ROIs$logFC, decreasing = T),]
# Find all rows-of-interest (ROIs) for morph(s)-of-interest where logFC is
# below specified value, and condition matches the input specification
}else{
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$PValue > tr.thresh) &
(in_table$Condition == condition)), ]
# Sort candidate rows with highest p values on top
ROIs <- ROIs[order(ROIs$PValue, decreasing = T),]
}
# If genes whose value is below the provided stat were requested...
}else if(direction == "Below"){
# Find all rows-of-interest (ROIs) for morph(s)-of-interest where logFC is
# BELOW specified value, and condition matches the input specification
if(tr.stat == "logFC"){
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$logFC < tr.thresh) &
(in_table$Condition == condition)), ]
# Sort candidate rows with SMALLEST logFC values on top
ROIs <- ROIs[order(ROIs$logFC, decreasing = F),]
}else{
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$PValue < tr.thresh) &
(in_table$Condition == condition)), ]
ROIs <- ROIs[order(ROIs$PValue, decreasing = F),]
}
}
# Obtain GO terms for ROIs
GOTerms <- character(length = nrow(ROIs))
for(i in 1:length(GOTerms)){
if(length(grep(ROIs$Gene_stable_ID[i], GeneToGO$Ensembl)) != 0){
GOTerms[i] = paste(GeneToGO$Gene.ontology.IDs[GeneToGO$Ensembl == ROIs$Gene_stable_ID[i]], collapse = " ")
}else{
GOTerms[i] = NA
}
}
GOTerms
ROIs$Gene_stable_ID[i]
GeneToGO
GeneToGO$Ensembl
ROIs
in_table
search_cond
in_table$Comparison
grepl(search_cond, in_table$Comparison)
in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$logFC > tr.thresh) &
(in_table$Condition == condition)), ]
ROIs
length(ROIs)
nrow(ROIs)
data.frame("No genes found matching given parameters.")
runApp()
runApp()
runApp()
runApp()
TTout <- as.data.frame(rep(NA,11))
TTout
as.data.frame(matrix(rep(NA,11), ncol = 11))
output.df <- as.data.frame(matrix(rep(NA,11), ncol = 11))
names(output.df) <- c("Gene Name","Gene Stable ID","GO Term(s)","Comparison",
"logFC","p-value","Age at Sampling","Tissue","Ensembl Family Description",
"Publication"
)
output.df
wrnings <- c("Errors: ")
# If condition is NOT "Between morph"...
if(condition != "Between morph"){
# Use transcription data of morph-control comparisons
in_table <- condition_control
# Set morph2 to control
morph2 <- "Control"
# Set grep pattern to morph1
search_cond <- morph1
# If searching between morphs, set search condition to morphs-of-comparison
}else if(condition == "Between morph"){
# Use transcription data for between-morph comparisons
in_table <- morph1.morph2
# Set grep pattern to comparison
search_cond <- paste(c(morph1, morph2), collapse = "-")
}
# Store comparison for output. Note: "morph2" is control if "Between morph"
# was not entered
comp <- paste(c(morph1, morph2), collapse = "-")
# If genes above threshold were requested...
if(direction == "Above"){
# Find all rows-of-interest (ROIs) for morph(s)-of-interest where logFC is
# above specified value, and condition matches the input specification
if(tr.stat == "logFC"){
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$logFC > tr.thresh) &
(in_table$Condition == condition)), ]
# Sort candidate rows with highest logFC values on top
ROIs <- ROIs[order(ROIs$logFC, decreasing = T),]
# Find all rows-of-interest (ROIs) for morph(s)-of-interest where logFC is
# below specified value, and condition matches the input specification
}else{
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$PValue > tr.thresh) &
(in_table$Condition == condition)), ]
# Sort candidate rows with highest p values on top
ROIs <- ROIs[order(ROIs$PValue, decreasing = T),]
}
# If genes whose value is below the provided stat were requested...
}else if(direction == "Below"){
# Find all rows-of-interest (ROIs) for morph(s)-of-interest where logFC is
# BELOW specified value, and condition matches the input specification
if(tr.stat == "logFC"){
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$logFC < tr.thresh) &
(in_table$Condition == condition)), ]
# Sort candidate rows with SMALLEST logFC values on top
ROIs <- ROIs[order(ROIs$logFC, decreasing = F),]
}else{
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$PValue < tr.thresh) &
(in_table$Condition == condition)), ]
ROIs <- ROIs[order(ROIs$PValue, decreasing = F),]
}
}
# Check if any genes were found for specified conditions
if(nrow(ROIs) == 0){
wrnings <- append(wrnings, "No genes found matching given parameters.")
output.df <- as.data.frame(matrix(rep(NA,11), ncol = 11))
names(output.df) <- c("Gene Name","Gene Stable ID","GO Term(s)","Comparison",
"logFC","p-value","Age at Sampling","Tissue","Ensembl Family Description",
"Publication"
)
return(list(output.df, wrnings))
}
list(output.df, wrnings)
runApp()
runApp()
shiny::runApp()
