temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# For each index, collect all genes, scaffolds, populations, values,
# and publication names whose stat values fall above the entered value
genes <- append(genes,temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] >= thresh])
DF_pops <- append(DF_pops,rep(pop_strings[i],
length(temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] >= thresh])))
stat_vals <- append(stat_vals,temp_stat_table[
temp_stat_table[,indices[i]] >= thresh,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[
temp_stat_table[,indices[i]] >= thresh])
}
# If lower tail was requested, iterate through each index
}else if(UL == "bottom"){
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# For each index, collect all genes, populations, and statistic values
# whose values fall in lowest tail
genes <- append(genes,temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] <= thresh])
DF_pops <- append(DF_pops,rep(pop_strings[i],
length(temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] <= thresh])))
stat_vals <- append(stat_vals,temp_stat_table[
temp_stat_table[,indices[i]] <= thresh,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[
temp_stat_table[,indices[i]] <= thresh])
}
}
# If count was entered...
}else if(in_type == "Gene Count"){
# Check whether top or bottom proportion was requested
# If top count was requested, iterate through each index
if(UL == "top"){
# Check if statistic is a one or a two population statistic
# If statistic is a two-population statistic, output the top N genes for ALL
# possible population pairs
if(stat_type == "Two Pop"){
# For each index...
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# Collect positions of top N genes for the current index
top_genes <- order(
temp_stat_table[,indices[i]], decreasing = T)[1:thresh]
# Collect the genes with the highest values, as well as the associated
# populations and values
genes <- append(genes,temp_stat_table$Gene_Name[top_genes])
DF_pops <- append(DF_pops,rep(pop_strings[i],length(top_genes)))
stat_vals <- append(stat_vals,temp_stat_table[top_genes,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[
top_genes])
}
# If statistic is a one-population statistic, output collect the N genes
# with the HIGHEST stat value, regardless of pop
}else if(stat_type == "One Pop"){
# Collect stat values for ALL indices into a 3 vectors: row
# in one column, population name in another,and stat value in the other
all_stats <- c()
all_pops <- c()
all_genes <- c()
all_pubs <- c()
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
all_stats <- append(all_stats, temp_stat_table[,indices[i]])
all_pops <- append(all_pops,rep(pop_strings[i],
length(temp_stat_table[,indices[i]])))
all_genes <- append(all_genes, temp_stat_table$Gene_Name[top_genes])
all_pubs <- append(all_genes, temp_stat_table$Publication)
}
# Organize vectors into a dataframe
temp_df <- data.frame(
all_stats,
all_pops,
all_genes,
all_pubs
)
# Retrieve the parallel indices for the N highest genes
par_indices <- order(temp_df$all_stats, decreasing = T)[1:thresh]
# Retrieve the gene names, population names, stat values, and
# publication names
genes <- append(genes,temp_df$all_genes[par_indices])
DF_pops <- append(DF_pops,temp_df$all_pops[par_indices])
stat_vals <- append(stat_vals,temp_df$all_stats[par_indices])
pub_names <- append(pub_names,temp_df$all_pubs[par_indices])
}
# If lower proportion was requested, iterate through each index
}else if(UL == "bottom"){
# Check if statistic is a one or a two population statistic
# If statistic is a two-population statistic, output the bottom N genes for ALL
# possible population pairs
if(stat_type == "Two Pop"){
# For each index...
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# Collect positions of bottom N genes for the current index
bottom_genes <- order(temp_stat_table[,indices[i]], decreasing = F)[1:thresh]
# Collect the genes with the highest values, as well as the
# associated populations, values, and publications
genes <- append(genes,temp_stat_table$Gene_Name[bottom_genes])
DF_pops <- append(DF_pops,rep(pop_strings[i],length(bottom_genes)))
stat_vals <- append(stat_vals,temp_stat_table[bottom_genes,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[bottom_genes])
}
# If statistic is a one-population statistic, output collect the N genes
# with the HIGHEST stat value, regardless of pop
}else if(stat_type == "One Pop"){
# Collect stat values for ALL indices into a 3 vectors: row
# in one column, population name in another,and stat value in the other
all_stats <- c()
all_pops <- c()
all_genes <- c()
all_pubs <- c()
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
all_stats <- append(all_stats, temp_stat_table[,indices[i]])
all_pops <- append(all_pops,rep(pop_strings[i],
length(temp_stat_table[,indices[i]])))
all_genes <- append(all_genes, temp_stat_table$Gene_Name)
all_pubs <- append(all_genes, temp_stat_table$Publication)
}
# Organize vectors into a dataframe
temp_df <- data.frame(
all_stats,
all_pops,
all_genes,
all_pubs
)
# Retreat the parallel indeices for the N highest genes
par_indices <- order(temp_df$all_stats, decreasing = F)[1:thresh]
# Retrieve the gene names, population names
genes <- append(genes,temp_df$all_genes[par_indices])
DF_pops <- append(DF_pops,temp_df$all_pops[par_indices])
stat_vals <- append(stat_vals,temp_df$all_stats[par_indices])
pub_names <- append(pub_names,temp_df$all_pubs[par_indices])
}
}
}
# If no population pairs were found, output an error
if(length(indices) == 0){
null.df <- data.frame(matrix(nrow = 1, ncol = 7))
names(null.df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Publication"
)
return(list(paste(c("Statistic",stat,"not present for the selected population(s)"),
collapse = " "), null.df))
}
# Initialize a vector of GO terms and a vector of scaffolds
scaffs <- character(length = length(genes))
DF_GOs <- character(length = length(genes))
# For each gene in the gene vector, output the associated scaffolds to the
# vector of scaffolds and output the associated GO terms to the vector of GO
# terms
for(g in 1:length(genes)){
# If gene is present in positions table and GO table, obtain scaffold and GO
# terms
if((genes[g] %in% position_table$Gene_Name) & (genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = position_table$Scaffold[position_table$Gene_Name == genes[g]]
DF_GOs[g] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == genes[g]][1]
# If gene is present in position table but NOT GO table, output NA for GO
# term but output real scaffold
}else if((genes[g] %in% position_table$Gene_Name) & !(genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = position_table$Scaffold[position_table$Gene_Name == genes[g]]
DF_GOs[g] = "Not applicable"
# If gene is present in GO table but NOT position table, output NA for scaffold
# term but output real GO
}else if(!(genes[g] %in% position_table$Gene_Name) & (genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = "Not applicable"
DF_GOs[g] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == genes[g]][1]
# If gene is present in neither GO nor position tables, output NA for scaff
# and GO
}else if(!(genes[g] %in% position_table$Gene_Name) & !(genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = "Not applicable"
DF_GOs[g] = "Not applicable"
}
}
# Create a dataframe of scaffolds, gene names, GO terms, statistic types, and
# stat values.
prelim_df <- data.frame(
DF_pops,
stat_vals,
scaffs,
genes,
DF_GOs,
pub_names
)
# Sort into a final dataframe
final_df <- data.frame()
# Sort df based on statistic values
# If "top" was checked, sort dataframe in DESCENDING order from top to bottom
# but retain population groups
if(UL == "top"){
# If statistic is a two-population statistic, sort WITHIN populations PRIOR
# to sorting by statistic
if(stat_type == "Two Pop"){
# Create vector in which to store number of genes falling above threshhold
# for each population pair
ranks <- c()
for(i in 1:length(pop_strings)){
rows <- prelim_df[prelim_df$DF_pops == pop_strings[i],]
new_rows <- rows[order(rows$stat_vals, decreasing = T),]
# Collect number of genes found above threshold for THIS population
ranks <- append(ranks, 1:nrow(new_rows))
final_df <- rbind(final_df, new_rows)
}
# Add column which ranks within each population pair
final_df <- add_column(final_df, ranks,.before = T)
# If statistic is a one-population statistic, sort ONLY by statistic value
}else if(stat_type == "One Pop"){
final_df <- prelim_df[order(stat_vals, decreasing = T),]
final_df <- add_column(final_df, 1:nrow(prelim_df),
.before = T)
}
# If "bottom" was checked, sort dataframe in ASCENDING order from top to bottom
# but retain population groups
}else if(UL == "bottom"){
if(stat_type == "Two Pop"){
# Create vector in which to store number of genes falling above threshhold
# for each population pair
ranks <- c()
for(i in 1:length(pop_strings)){
rows <- prelim_df[prelim_df$DF_pops == pop_strings[i],]
new_rows <- rows[order(rows$stat_vals, decreasing = F),]
# Collect number of genes found above threshhold for THIS population
ranks <- append(ranks, 1:nrow(new_rows))
final_df <- rbind(final_df, new_rows)
}
# Add column which ranks within each population pair
final_df <- add_column(final_df, ranks,.before = T)
}else if(stat_type == "One Pop"){
final_df <- prelim_df[order(stat_vals, decreasing = F),]
# Add rank column
final_df <- add_column(final_df, 1:nrow(prelim_df),
.before = T)
}
}
# Rename df stat type and stat value columns with specific statistic's name
names(final_df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Publication"
)
# Output df and warnings
if(is.na(final_df[1,2])){
final_df <- final_df[-1,]
}
list(wrnings, final_df)
thresh
thresh = 10
thresh = 0.9
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
foo <- data.frame(x = c("a","b","c"))
new <- foo[order(foo),]
new <- foo[order(x),]
foo
foo <- data.frame(col_nm = c("a","b","c"))
new <- foo[order(col_nm),]
new <- foo[order(foo$col_nm),]
foo
new
foo <- data.frame(col_nm = c("a","b","c"), col_nm2 = c("x", "y", "z"))
new <- foo[order(foo$col_nm),]
new
new <- foo[order(-foo$col_nm),]
?order
new <- foo[order(foo$col_nm, decreasing = T),]
new
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?order
foo <- data.frame(col1 = c(1e100, 2e50))
foo
foo[order(foo$col1),]
foo <- data.frame(col1 = c(1e100, 2e50, 2e100))
foo[order(foo$col1),]
runApp()
runApp()
?format
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
?order
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
?geom_point
?aes
runApp()
runApp()
runApp()
################################## Load Data ###################################
# Make dataframe of latitudes and longitudes for all morphs
# Citation:
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3282648/pdf/1471-2148-12-9.pdf
Latit_Longit_unedited <- data.frame(
Population = c("Pachon","Yerbaniz","Japonis","Arroyo","Tinaja","Curva","Toro",
"Chica","Molino","Caballo Moro","Subterraneo","Rio Frio",
"Arroyo Sarco", "Chamal","Rio Meco","Rio Tantaon","Rio Florido",
"Rio Tampaon","Nacimiento del Rio Santa Clara",
"San Rafael Los Castros","Rio Subterraneo Valley"),
Latitude = c(22.60,22.20,22.10,22.20,22.08,21.98,21.85,21.85,23.06,22.92,
22.10,22.99,22.02,22.84,22.82,22.37,21.98,21.85,22.50,22.75,22.13
),
Longitude = c(-99.05,-98.97,-98.95,-98.97,-98.95,-98.93,-98.93,-98.93,-99.16,
-99.20,-99.18,-99.15,-99.32,-99.20,-99.31,-98.90,-98.77,-98.94,-98.9,
-99.02,-99.17
),
Morph = c(rep("Cave",10), rep("Surface", 11))
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?geom_point
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
library("ggrepel ")
library("ggrepel")
runApp()
runApp()
runApp()
?geom_label_repel
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
