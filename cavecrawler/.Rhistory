morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Age at Sampling` <- morph1.morph2$Age_at_Sampling[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$Tissue <- morph1.morph2$Tissue[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
tempTransc$Publication <- morph1.morph2$Publication[
morph1.morph2$Gene_stable_ID == geneIDs[i]
]
finalTransc <- rbind(finalTransc, tempTransc)
}
if(geneIDs[i] %in% condition_control$Gene_stable_ID){
# If there is transcription data for condition-control comparisons, add
# this data to a temporary dataframe and bind the temp dataframe to the
# final
transcAbsent <- F
tempTransc <- data.frame(matrix(
nrow = sum(condition_control$Gene_stable_ID == geneIDs[i]), ncol = 11))
names(tempTransc) <- c("Gene ID","Gene name","Gene description",
"Study-specific information","Comparison",
"logFC","p-value","Condition","Age at Sampling",
"Tissue","Publication")
# Since there may be multiple rows corresponding to a single gene ID,
# output as many gene IDs as there are copies
tempTransc$`Gene ID` <- condition_control$Gene_stable_ID[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Gene name` <- condition_control$Gene_name[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Gene description` <- condition_control$Gene_description[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Study-specific information` <- "Not available for this study"
tempTransc$Comparison <- condition_control$Comparison[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$logFC <- condition_control$logFC[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`p-value` <- condition_control$PValue[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$Condition <- condition_control$Condition[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$`Age at Sampling` <- condition_control$Age_at_Sampling[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$Tissue <- condition_control$Tissue[
condition_control$Gene_stable_ID == geneIDs[i]
]
tempTransc$Publication <- condition_control$Publication[
condition_control$Gene_stable_ID == geneIDs[i]
]
finalTransc <- rbind(finalTransc, tempTransc)
}
# If there is no transcription data for this gene in either class, output
# a warning
if(transcAbsent){
warn <- append(warn, paste(c("Transcriptional data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
# If popgen data was requested...
if(popgenBool){
if(geneIDs[i] %in% stat_table$Stable_Gene_ID){
# Create a subset of the stat_table dataframe
subsetPopgen <- subset(stat_table, subset = Stable_Gene_ID == geneIDs[i])
# For each row in the subset dataframe, search each STATISTIC column and
# dissect the column information into a row of the temporary dataframe
for(r in 1:nrow(subsetPopgen)){
for(c in 1:ncol(stat_table)){
# First, check that this is a statistic column
if(typeof(stat_table[,c]) == "double"){
# Ensure the current statistic value is not simply NA
if(!is.na(subsetPopgen[r,c])){
# Create a temporary dataframe with just a single row
tempPopgen <- data.frame(matrix(nrow = 1, ncol = 7))
names(tempPopgen) <- c("Gene ID","Gene name","Gene description",
"Statistic Type","Population(s)","Statistic Value",
,"Publication")
tempPopgen$`Gene ID`[1] <- geneIDs[i]
tempPopgen$`Gene name`[1] <- subsetPopgen$Gene_Name[r]
tempPopgen$`Gene description`[1] <- subsetPopgen$Gene_Description[r]
names_pops <- str_split(names(subsetPopgen)[c], "_")[[1]]
tempPopgen$`Statistic Type`[1] <- names_pops[1]
tempPopgen$`Population(s)`[1] <- names_pops[2]
tempPopgen$`Statistic Value`[1] <- subsetPopgen[r,c]
tempPopgen$Publication[1] <- subsetPopgen$Publication[r]
finalPopgen <- rbind(finalPopgen, tempPopgen)
}
}
}
}
# Bind the temporary dataframe to the final
}else{
# If the gene ID is not present in the statistical data, output a warning
warn <- append(warn, paste(c("Population genetics data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
# If GO data was requested...
if(GOBool){
# Check if this gene ID is present in the position table
if(geneIDs[i] %in% GeneToGO$Ensembl_GeneID){
# If so, output the gene ID's GO info to the final dataframe
finalGO$`Gene ID`[i] <- geneIDs[i]
finalGO$`Gene name`[i] <- GeneToGO$Gene.names[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Gene Ontology IDs`[i] <- GeneToGO$Gene.ontology.IDs[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Biological Process`[i] <- GeneToGO$Gene.ontology..biological.process.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Cellular Component`[i] <- GeneToGO$Gene.ontology..cellular.component.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$`Molecular Function`[i] <- GeneToGO$Gene.ontology..molecular.function.[
GeneToGO$Ensembl_GeneID == geneIDs[i]]
finalGO$Publication[i] <- "7"
}else{
# If not, output all NAs at the corresponding row in the dataframe so the
# length of the dataframe stays consistent. Remove these rows later
finalGO[i,] <- rep(NA, ncol(finalGO))
# Output a warning saying that GO data is not present for this
# ID
warn <- append(warn, paste(c("GO data not present for gene ID ",
geneIDs[i]), collapse = ""))
}
}
}
# Once you have each of the dataframes, remove all NA rows from each dataframe
# which is supposed to have and output, then output all 4 dataframes AND
# warnings as a list
if(posBool){
finalPos <- finalPos[!is.na(finalPos$`Gene ID`),]
}
source("C:/Users/knigh/Documents/GitHub/CaveCrawler/cavecrawler/functions/CaveCrawler_functions.R")
GeneSearch(input = "sleep", posBool = F, transcBool = T, popgenBool = T, GOBool = F,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
source("C:/Users/knigh/Documents/GitHub/CaveCrawler/cavecrawler/functions/CaveCrawler_functions.R")
GeneSearch(input = "sleep", posBool = F, transcBool = T, popgenBool = T, GOBool = F,
position_table, morph1.morph2, condition_control,
stat_table, GeneToGO)
StatDistTable(in_type = "Statistic Value", UL = "top", thresh = 0.9, stat = "Fst", stat_table, pops = c("Pachon","Rascon"))
runApp()
in_type = "Gene Count"
UL = "bottom"
stat = "Fst"
threshpops <- c("Pachon","RioChoy")
# Create 2 vectors of the indices corresponding to each population or pop
# pair's statistic values
indices <- c()
pop_strings <- c()
# Create vector into which warnings will be stored for later output
wrnings <- c("Notes:\n")
# Check if statistic of interest makes comparisons between TWO populations
if((stat == "Fst") | (stat == "Dxy")){
# Tell the program that a two-population statistic was entered so the
# program outputs the specified number of genes for EACH population
stat_type = "Two Pop"
# Find all population pairs
two_pops <- combn(pops,2)
# If so, iterate through each combination of pops and output the indices
# and string version of the population pair
for(pair in 1:ncol(two_pops)){
# If pops is a matrix, read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "index" equal to the column housing this statistic
val <- which(grepl(two_pops[1, pair], names(stat_table))
& grepl(two_pops[2, pair], names(stat_table))
& grepl(stat, names(stat_table)))
# If statistic for populations-of-interest is not present, return error
if(length(val) == 0){
wrnings <- append(wrnings, (paste(c("Statistic",stat,
"is not present for the populations",two_pops[1, pair],"and",
two_pops[2, pair], "\n"),collapse = " ")))
# If these populations-of-interest are the only pops which were
# inputted, return a warning
if(ncol(two_pops) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 7))
names(null.df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Publication"
)
return(list(paste(c("Statistic ",stat,
" is not present for the populations ",
two_pops[1, pair]," and ",
two_pops[2, pair]),collapse = ""),
null.df))
}
}else{
# Create a row to add to the indices dataframe
temp_str <- paste(c(two_pops[1, pair],"-",two_pops[2, pair]), collapse = "")
pop_strings <- append(pop_strings,temp_str)
indices <- append(indices,val)
}
# If pops is NOT a matrix, return an error
}
}else if((stat == "TajimasD") | (stat == "Pi")){
# Tell the program that a one-population statistic was entered so the
# program outputs the specified number of genes across ALL populations
stat_type = "One Pop"
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
val <- which(grepl(pops[p], names(stat_table))
& grepl(stat, names(stat_table)))
# If statistic for populations-of-interest is not present, return a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, (paste(c("Statistic",stat,
"is not present for the population",
pops[p],"\n"),collapse = " ")))
}else{
pop_strings <- append(pop_strings,pops[p])
indices <- append(indices,val)
}
}
}else{
return("ERROR: Invalid statistic name")
}
# Initialize vectors of gene names, populations, statistic values, and
# publication names
genes <- c()
DF_pops <- c()
stat_vals <- c()
pub_names <- c()
# Check if statistic value or gene count was entered
# If value was entered...
if(in_type == "Statistic Value"){
# Check whether top or bottom proportion was requested
# If higher proportion was requested, iterate through each index
if(UL == "top"){
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# For each index, collect all genes, scaffolds, populations, values,
# and publication names whose stat values fall above the entered value
genes <- append(genes,temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] >= thresh])
DF_pops <- append(DF_pops,rep(pop_strings[i],
length(temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] >= thresh])))
stat_vals <- append(stat_vals,temp_stat_table[
temp_stat_table[,indices[i]] >= thresh,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[
temp_stat_table[,indices[i]] >= thresh])
}
# If lower tail was requested, iterate through each index
}else if(UL == "bottom"){
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# For each index, collect all genes, populations, and statistic values
# whose values fall in lowest tail
genes <- append(genes,temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] <= thresh])
DF_pops <- append(DF_pops,rep(pop_strings[i],
length(temp_stat_table$Gene_Name[
temp_stat_table[,indices[i]] <= thresh])))
stat_vals <- append(stat_vals,temp_stat_table[
temp_stat_table[,indices[i]] <= thresh,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[
temp_stat_table[,indices[i]] <= thresh])
}
}
# If count was entered...
}else if(in_type == "Gene Count"){
# Check whether top or bottom proportion was requested
# If top count was requested, iterate through each index
if(UL == "top"){
# Check if statistic is a one or a two population statistic
# If statistic is a two-population statistic, output the top N genes for ALL
# possible population pairs
if(stat_type == "Two Pop"){
# For each index...
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# Collect positions of top N genes for the current index
top_genes <- order(
temp_stat_table[,indices[i]], decreasing = T)[1:thresh]
# Collect the genes with the highest values, as well as the associated
# populations and values
genes <- append(genes,temp_stat_table$Gene_Name[top_genes])
DF_pops <- append(DF_pops,rep(pop_strings[i],length(top_genes)))
stat_vals <- append(stat_vals,temp_stat_table[top_genes,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[
top_genes])
}
# If statistic is a one-population statistic, output collect the N genes
# with the HIGHEST stat value, regardless of pop
}else if(stat_type == "One Pop"){
# Collect stat values for ALL indices into a 3 vectors: row
# in one column, population name in another,and stat value in the other
all_stats <- c()
all_pops <- c()
all_genes <- c()
all_pubs <- c()
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
all_stats <- append(all_stats, temp_stat_table[,indices[i]])
all_pops <- append(all_pops,rep(pop_strings[i],
length(temp_stat_table[,indices[i]])))
all_genes <- append(all_genes, temp_stat_table$Gene_Name[top_genes])
all_pubs <- append(all_genes, temp_stat_table$Publication)
}
# Organize vectors into a dataframe
temp_df <- data.frame(
all_stats,
all_pops,
all_genes,
all_pubs
)
# Retrieve the parallel indices for the N highest genes
par_indices <- order(temp_df$all_stats, decreasing = T)[1:thresh]
# Retrieve the gene names, population names, stat values, and
# publication names
genes <- append(genes,temp_df$all_genes[par_indices])
DF_pops <- append(DF_pops,temp_df$all_pops[par_indices])
stat_vals <- append(stat_vals,temp_df$all_stats[par_indices])
pub_names <- append(pub_names,temp_df$all_pubs[par_indices])
}
# If lower proportion was requested, iterate through each index
}else if(UL == "bottom"){
# Check if statistic is a one or a two population statistic
# If statistic is a two-population statistic, output the bottom N genes for ALL
# possible population pairs
if(stat_type == "Two Pop"){
# For each index...
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
# Collect positions of bottom N genes for the current index
bottom_genes <- order(temp_stat_table[,indices[i]], decreasing = F)[1:thresh]
# Collect the genes with the highest values, as well as the
# associated populations, values, and publications
genes <- append(genes,temp_stat_table$Gene_Name[bottom_genes])
DF_pops <- append(DF_pops,rep(pop_strings[i],length(bottom_genes)))
stat_vals <- append(stat_vals,temp_stat_table[bottom_genes,indices[i]])
pub_names <- append(pub_names,temp_stat_table$Publication[bottom_genes])
}
# If statistic is a one-population statistic, output collect the N genes
# with the HIGHEST stat value, regardless of pop
}else if(stat_type == "One Pop"){
# Collect stat values for ALL indices into a 3 vectors: row
# in one column, population name in another,and stat value in the other
all_stats <- c()
all_pops <- c()
all_genes <- c()
all_pubs <- c()
for(i in 1:length(indices)){
# First, remove all NA values for this index
temp_stat_table <- stat_table[!is.na(stat_table[,indices[i]]),]
all_stats <- append(all_stats, temp_stat_table[,indices[i]])
all_pops <- append(all_pops,rep(pop_strings[i],
length(temp_stat_table[,indices[i]])))
all_genes <- append(all_genes, temp_stat_table$Gene_Name)
all_pubs <- append(all_genes, temp_stat_table$Publication)
}
# Organize vectors into a dataframe
temp_df <- data.frame(
all_stats,
all_pops,
all_genes,
all_pubs
)
# Retreat the parallel indeices for the N highest genes
par_indices <- order(temp_df$all_stats, decreasing = F)[1:thresh]
# Retrieve the gene names, population names
genes <- append(genes,temp_df$all_genes[par_indices])
DF_pops <- append(DF_pops,temp_df$all_pops[par_indices])
stat_vals <- append(stat_vals,temp_df$all_stats[par_indices])
pub_names <- append(pub_names,temp_df$all_pubs[par_indices])
}
}
}
# If no population pairs were found, output an error
if(length(indices) == 0){
null.df <- data.frame(matrix(nrow = 1, ncol = 7))
names(null.df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Publication"
)
return(list(paste(c("Statistic",stat,"not present for the selected population(s)"),
collapse = " "), null.df))
}
# Initialize a vector of GO terms and a vector of scaffolds
scaffs <- character(length = length(genes))
DF_GOs <- character(length = length(genes))
# For each gene in the gene vector, output the associated scaffolds to the
# vector of scaffolds and output the associated GO terms to the vector of GO
# terms
for(g in 1:length(genes)){
# If gene is present in positions table and GO table, obtain scaffold and GO
# terms
if((genes[g] %in% position_table$Gene_Name) & (genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = position_table$Scaffold[position_table$Gene_Name == genes[g]]
DF_GOs[g] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == genes[g]][1]
# If gene is present in position table but NOT GO table, output NA for GO
# term but output real scaffold
}else if((genes[g] %in% position_table$Gene_Name) & !(genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = position_table$Scaffold[position_table$Gene_Name == genes[g]]
DF_GOs[g] = "Not applicable"
# If gene is present in GO table but NOT position table, output NA for scaffold
# term but output real GO
}else if(!(genes[g] %in% position_table$Gene_Name) & (genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = "Not applicable"
DF_GOs[g] = GeneToGO$Gene.ontology.IDs[GeneToGO$Gene.names == genes[g]][1]
# If gene is present in neither GO nor position tables, output NA for scaff
# and GO
}else if(!(genes[g] %in% position_table$Gene_Name) & !(genes[g] %in% GeneToGO$Gene.names)){
scaffs[g] = "Not applicable"
DF_GOs[g] = "Not applicable"
}
}
# Create a dataframe of scaffolds, gene names, GO terms, statistic types, and
# stat values.
prelim_df <- data.frame(
DF_pops,
stat_vals,
scaffs,
genes,
DF_GOs,
pub_names
)
# Sort into a final dataframe
final_df <- data.frame()
# Sort df based on statistic values
# If "top" was checked, sort dataframe in DESCENDING order from top to bottom
# but retain population groups
if(UL == "top"){
# If statistic is a two-population statistic, sort WITHIN populations PRIOR
# to sorting by statistic
if(stat_type == "Two Pop"){
# Create vector in which to store number of genes falling above threshhold
# for each population pair
ranks <- c()
for(i in 1:length(pop_strings)){
rows <- prelim_df[prelim_df$DF_pops == pop_strings[i],]
new_rows <- rows[order(rows$stat_vals, decreasing = T),]
# Collect number of genes found above threshold for THIS population
ranks <- append(ranks, 1:nrow(new_rows))
final_df <- rbind(final_df, new_rows)
}
# Add column which ranks within each population pair
final_df <- add_column(final_df, ranks,.before = T)
# If statistic is a one-population statistic, sort ONLY by statistic value
}else if(stat_type == "One Pop"){
final_df <- prelim_df[order(stat_vals, decreasing = T),]
final_df <- add_column(final_df, 1:nrow(prelim_df),
.before = T)
}
# If "bottom" was checked, sort dataframe in ASCENDING order from top to bottom
# but retain population groups
}else if(UL == "bottom"){
if(stat_type == "Two Pop"){
# Create vector in which to store number of genes falling above threshhold
# for each population pair
ranks <- c()
for(i in 1:length(pop_strings)){
rows <- prelim_df[prelim_df$DF_pops == pop_strings[i],]
new_rows <- rows[order(rows$stat_vals, decreasing = F),]
# Collect number of genes found above threshhold for THIS population
ranks <- append(ranks, 1:nrow(new_rows))
final_df <- rbind(final_df, new_rows)
}
# Add column which ranks within each population pair
final_df <- add_column(final_df, ranks,.before = T)
}else if(stat_type == "One Pop"){
final_df <- prelim_df[order(stat_vals, decreasing = F),]
# Add rank column
final_df <- add_column(final_df, 1:nrow(prelim_df),
.before = T)
}
}
# Rename df stat type and stat value columns with specific statistic's name
names(final_df) <- c(
"Rank",
"Population(s)",
stat,
"Scaffold",
"Gene Name",
"GO Term(s)",
"Publication"
)
# Output df and warnings
if(is.na(final_df[1,2])){
final_df <- final_df[-1,]
}
list(wrnings, final_df)
thresh
thresh = 10
thresh = 0.9
StatDistTable(in_type, UL, stat, thresh, stat_table, pops)
runApp()
runApp()
