size=N, replace = T)
}else{
dads <- rep((1:N)[sexes=="mal"], N)
}
parents <- list(moms,dads)
names(parents) <- c("Moms","Dads")
return(parents)
}
# 4 make gametes
# pop = list of genomes
# parent = list of two sets of integers describing the individuals in pop who
# get to breed
# PARb = Starting locus of pseudoautosomal region of the male sex chromosomes
# Output (gametes) = list of two sets of vectors each describing the sequence
# of a haploid gamete
MakeGametes <- function(pop, parents, chiasm = T){
gametes <- vector(mode="list",length=2)
names(gametes) <- c("eggs","sperm")
# Iterate through each pair of parents
for(i in 1:length(parents$Dads)){
# For male...
# If individual is chiasmatic...
if(chiasm){
# Pick 3 random sites OTHER than 13, 36, and 61 in...
# PAR ((PARb+1):24)
# Autosome I (27:49)
# Autosome II (52-99)
# ... at which recombination occurs (recombination CANNOT occur at first or
# final locus of a chromosome, so these loci are excluded)
SexRec <- sample(2:13, 1)
Chr1Rec <- sample(27:49, 1)
Chr2Rec <- sample(52:99, 1)
# For each chromosome, create two recombinant homologs and add to vectors
# from which gametes will be selected
SexChrGametes <- c(
paste(c(pop[[parents$Dads[i]]][2,1:(SexRec-1)],
pop[[parents$Dads[i]]][1,SexRec:25]), collapse = ","),
paste(c(pop[[parents$Dads[i]]][1,1:(SexRec-1)],
pop[[parents$Dads[i]]][2,SexRec:25]), collapse = ",")
)
Chr1Gametes <- c(
paste(c(pop[[parents$Dads[i]]][2,26:(Chr1Rec-1)],
pop[[parents$Dads[i]]][1,Chr1Rec:50]), collapse = ","),
paste(c(pop[[parents$Dads[i]]][1,26:(Chr1Rec-1)],
pop[[parents$Dads[i]]][2,Chr1Rec:50]), collapse = ",")
)
Chr2Gametes <- c(
paste(c(pop[[parents$Dads[i]]][2,51:(Chr2Rec-1)],
pop[[parents$Dads[i]]][1,Chr2Rec:100]), collapse = ","),
paste(c(pop[[parents$Dads[i]]][1,51:(Chr2Rec-1)],
pop[[parents$Dads[i]]][2,Chr2Rec:100]), collapse = ",")
)
# For each chromosome, randomly select ONE homolog from the two
# recombinant homologs and stick the 3 chromosomes together to create a
# haploid genome, adding this genome to the list of gametes under "sperm"
if(sum(pop[[parents$Dads[i]]][,25]) == 0){
gametes$sperm[i] <- paste(c(sample(SexChrGametes, 1),
sample(Chr1Gametes, 1),
sample(Chr2Gametes, 1)), collapse = ",")
}else if(1 %in% pop[[parents$Dads[i]]][,25]){
pick <- sample(1:2, 1)
gametes$sperm[i] <- paste(c(SexChrGametes[pick],
Chr1Gametes[pick],
sample(Chr2Gametes, 1)), collapse = ",")
}else if(2 %in% pop[[parents$Dads[i]]][,25]){
pick <- sample(1:2, 1)
gametes$sperm[i] <- paste(c(SexChrGametes[pick],
sample(Chr1Gametes, 1),
Chr2Gametes[pick]), collapse = ",")
}
}else{
pick <- sample(1:2, 3, replace = T)
gametes$sperm[i] <- paste(c(pop[[parents$Dads[i]]][pick[1],1:25],
pop[[parents$Dads[i]]][pick[2],26:50],
pop[[parents$Dads[i]]][pick[3],51:100]),
collapse = ",")
}
# For female..
# Pick 3 random sites OTHER than 13, 36, and 61 in...
# Sex chromosome (2:24)
# Autosome I (27:49)
# Autosome II (52-99)
# ... at which recombination occurs (recombination CANNOT occur at first or
# final locus of a chromosome, so these loci are excluded)
SexRec <- sample(2:24, 1)
Chr1Rec <- sample(27:49, 1)
Chr2Rec <- sample(52:99, 1)
# For each chromosome, create two recombinant homologs and add to vectors
# from which gametes will be selected
SexChrGametes <- c(
paste(c(pop[[parents$Moms[i]]][2,1:(SexRec-1)],
pop[[parents$Moms[i]]][1,SexRec:25]), collapse = ","),
paste(c(pop[[parents$Moms[i]]][1,1:(SexRec-1)],
pop[[parents$Moms[i]]][2,SexRec:25]), collapse = ",")
)
Chr1Gametes <- c(
paste(c(pop[[parents$Moms[i]]][2,26:(Chr1Rec-1)],
pop[[parents$Moms[i]]][1,Chr1Rec:50]), collapse = ","),
paste(c(pop[[parents$Moms[i]]][1,26:(Chr1Rec-1)],
pop[[parents$Moms[i]]][2,Chr1Rec:50]), collapse = ",")
)
Chr2Gametes <- c(
paste(c(pop[[parents$Moms[i]]][2,51:(Chr2Rec-1)],
pop[[parents$Moms[i]]][1,Chr2Rec:100]), collapse = ","),
paste(c(pop[[parents$Moms[i]]][1,51:(Chr2Rec-1)],
pop[[parents$Moms[i]]][2,Chr2Rec:100]), collapse = ",")
)
# For each chromosome, randomly select one homolog from the two
# recombinant homologs and stick these chromosomes together to create a
# haploid genome, adding this genome to the list of gametes under "eggs"
if(sum(pop[[parents$Moms[i]]][,25]) == 0){
gametes$eggs[i] <- paste(c(sample(SexChrGametes, 1),
sample(Chr1Gametes, 1),
sample(Chr2Gametes, 1)), collapse = ",")
}else if(1 %in% pop[[parents$Moms[i]]][,25]){
pick <- sample(1:2, 1)
gametes$eggs[i] <- paste(c(SexChrGametes[pick],
Chr1Gametes[pick],
sample(Chr2Gametes, 1)), collapse = ",")
}else if(2 %in% pop[[parents$Moms[i]]][,25]){
pick <- sample(1:2, 1)
gametes$eggs[i] <- paste(c(SexChrGametes[pick],
sample(Chr1Gametes, 1),
Chr2Gametes[pick]), collapse = ",")
}
}
# Return list of eggs and sperm
return(gametes)
}
# 7 make next gen
# gametes = List of strings describing the haplotypes of available eggs and
# sperm where each locus' fitness value is separated by a comma
# newgen = List of matrices describing each of the new individuals
MiracleOfLife <- function(gametes){
# New generation should be same size as number of couples
newgen <- vector(mode = "list", length = length(gametes$eggs))
# Until list of gametes is empty, sample a new mom and dad gamete and fuse
# together into a 2X100 matrix, adding to population
for(i in 1:length(newgen)){
# pick a mom and dad at random from the mating pool
e <- sample(1:length(gametes$eggs), 1)
s <- sample(1:length(gametes$sperm), 1)
# sex
newgen[[i]] <- matrix(as.numeric(c(strsplit(gametes$eggs[e], ",")[[1]],
strsplit(gametes$sperm[s], ",")[[1]])),
nrow = 2, byrow = T)
gametes$eggs <- gametes$eggs[-e]
gametes$sperm <- gametes$sperm[-s]
}
return(newgen)
}
# Runs the simulation on "pop_size" number of individuals for "gen_no"
# generations with an SAL selection coefficient of "s" and a PAR beginning locus
# of "PARb" and output the final population
Evolve <- function(pop_size, gen_no, s, chiasm, fus.type, mu.table){
# Get a new population
pop <- GetPop(pop_size)
# Get a distribution of fitness effects
dfe <- GetDFE()
# Initialize list of matrices
# For each matrix...
# Rows = Generations
# Columns = Individuals
results <- matrix(nrow = 4*gen_no, ncol = pop_size,
dimnames = list(
rep(c("X-SDR", "X/Y-SDR", "X-FuseLocus", "X/Y-FuseLocus"),
gen_no), 1:pop_size))
# Create iterator for the FOUR rows corresponding to the current generation
gen_rows <- 1:4
# For each generation in "gen_no"...
for(gen in 1:gen_no){
print(paste(c("Generation: ", gen), collapse = ""))
# Mutate the starting population
pop <- ActofGod(pop, dfe, fus.type, mu.table)
# Assess the fitness of the mutated population
fits <- GetFit(pop, s)
# Add loci and fitnesses to corresponding generation in output
for(i in 1:pop_size){
results[gen_rows, i] <- c(pop[[i]][,13], pop[[i]][,25])
}
# Select parents based on the fitness
parents <- Maury(pop, fits, length(pop))
# Select gametes from these parents
gametes <- MakeGametes(pop, parents, chiasm)
# Breed the parents
pop <- MiracleOfLife(gametes)
# Move to next two generation's rows
gen_rows <- gen_rows + 4
# Continue to next round of mutation
next
}
# Output final genome after this many generations
return(results)
}
for(sim in 1:runs){
# Must keep redefining mutation rate for some reason
print(" ")
print(paste(c("Simulation: ", sim), collapse = ""))
print("Achiasmy, X Fusions")
XAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"X",mu.table)
print("Chiasmy, X Fusions")
XChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"X",mu.table)
print("Achiasmy, Y Fusions")
YAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"Y",mu.table)
print("Chiasmy, Y Fusions")
YChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"Y",mu.table)
sim.rows <- sim.rows + (4*gen_no)
}
mu <- 0.01
s <- 0.9
for(sim in 1:runs){
# Must keep redefining mutation rate for some reason
print(" ")
print(paste(c("Simulation: ", sim), collapse = ""))
print("Achiasmy, X Fusions")
XAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"X",mu.table)
print("Chiasmy, X Fusions")
XChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"X",mu.table)
print("Achiasmy, Y Fusions")
YAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"Y",mu.table)
print("Chiasmy, Y Fusions")
YChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"Y",mu.table)
sim.rows <- sim.rows + (4*gen_no)
}
# Run simulation multiple times, storing output of each run as a new element in
# list
runs <- 10
pop_size <- 100
gen_no <- 1000
mu <- 0.01
s <- 0.9
# Get probabilities of 0, 1, 2, and 3 mutations in a generation
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
XAchiasmaticResults <- matrix(nrow = runs*gen_no*4, ncol = pop_size,
dimnames = list(
rep(c("X-SDR", "X/Y-SDR", "X-FuseLocus", "X/Y-FuseLocus"),
gen_no*runs)))
XChiasmaticResults <- XAchiasmaticResults
YAchiasmaticResults <- XAchiasmaticResults
YChiasmaticResults <- XAchiasmaticResults
sim.rows <- 1:(4*gen_no)
for(sim in 1:runs){
# Must keep redefining mutation rate for some reason
print(" ")
print(paste(c("Simulation: ", sim), collapse = ""))
print("Achiasmy, X Fusions")
XAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"X",mu.table)
print("Chiasmy, X Fusions")
XChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"X",mu.table)
print("Achiasmy, Y Fusions")
YAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"Y",mu.table)
print("Chiasmy, Y Fusions")
YChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"Y",mu.table)
sim.rows <- sim.rows + (4*gen_no)
}
# Run simulation multiple times, storing output of each run as a new element in
# list
runs <- 10
pop_size <- 100
gen_no <- 1000
mu <- 0.01
s <- 0.9
# Get probabilities of 0, 1, 2, and 3 mutations in a generation
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
XAchiasmaticResults <- matrix(nrow = runs*gen_no*4, ncol = pop_size,
dimnames = list(
rep(c("X-SDR", "X/Y-SDR", "X-FuseLocus", "X/Y-FuseLocus"),
gen_no*runs)))
XChiasmaticResults <- XAchiasmaticResults
YAchiasmaticResults <- XAchiasmaticResults
YChiasmaticResults <- XAchiasmaticResults
sim.rows <- 1:(4*gen_no)
for(sim in 1:runs){
# Must keep redefining mutation rate for some reason
print(" ")
print(paste(c("Simulation: ", sim), collapse = ""))
YAchiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,F,"Y",mu.table)
print("Chiasmy, Y Fusions")
YChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"Y",mu.table)
sim.rows <- sim.rows + (4*gen_no)
}
# Run simulation multiple times, storing output of each run as a new element in
# list
runs <- 10
pop_size <- 100
gen_no <- 1000
mu <- 0.01
s <- 0.9
# Get probabilities of 0, 1, 2, and 3 mutations in a generation
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
XAchiasmaticResults <- matrix(nrow = runs*gen_no*4, ncol = pop_size,
dimnames = list(
rep(c("X-SDR", "X/Y-SDR", "X-FuseLocus", "X/Y-FuseLocus"),
gen_no*runs)))
XChiasmaticResults <- XAchiasmaticResults
YAchiasmaticResults <- XAchiasmaticResults
YChiasmaticResults <- XAchiasmaticResults
sim.rows <- 1:(4*gen_no)
for(sim in 1:runs){
# Must keep redefining mutation rate for some reason
print(" ")
print("Chiasmy, Y Fusions")
YChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"Y",mu.table)
sim.rows <- sim.rows + (4*gen_no)
}
# Run simulation multiple times, storing output of each run as a new element in
# list
runs <- 5
pop_size <- 100
gen_no <- 1000
mu <- 0.01
s <- 0.9
# Get probabilities of 0, 1, 2, and 3 mutations in a generation
mu.table <- as.data.frame(
table(rbinom(n=100000, size=4*1587000, prob = mu))
)[1:4,2]/sum(as.data.frame(table(rbinom(n=100000, size=4*1587000, prob = mu)))[1:4,2])
XAchiasmaticResults <- matrix(nrow = runs*gen_no*4, ncol = pop_size,
dimnames = list(
rep(c("X-SDR", "X/Y-SDR", "X-FuseLocus", "X/Y-FuseLocus"),
gen_no*runs)))
XChiasmaticResults <- XAchiasmaticResults
YAchiasmaticResults <- XAchiasmaticResults
YChiasmaticResults <- XAchiasmaticResults
sim.rows <- 1:(4*gen_no)
for(sim in 1:runs){
# Must keep redefining mutation rate for some reason
print(" ")
print(paste(c("Simulation: ", sim), collapse = ""))
YChiasmaticResults[sim.rows,] <- Evolve(pop_size,gen_no,s,T,"Y",mu.table)
sim.rows <- sim.rows + (4*gen_no)
}
# For testing purposes
YChiasmaticResults.count <- matrix(nrow = runs, ncol = gen_no)
YChiasmaticResults.prop <- matrix(nrow = runs, ncol = gen_no)
for(sim in 1:nrow(YChiasmaticResults.count)){
print(paste(c("Sim: ", sim), collapse = ""))
for(gen in 1:ncol(YChiasmaticResults.count)){
YChiasmaticResults.count[sim, gen] <- sum(YChiasmaticResults[rows[4],] > 0)
Y.count <- sum(YChiasmaticResults[rows[2],])
YChiasmaticResults.prop[sim, gen] <- YChiasmaticResults.count[sim, gen]/Y.count
# Get rows for next set
rows <- rows + 4
}
}
X.count <- 0
Y.count <- 0
rows <- 1:4
for(sim in 1:nrow(YChiasmaticResults.count)){
print(paste(c("Sim: ", sim), collapse = ""))
for(gen in 1:ncol(YChiasmaticResults.count)){
YChiasmaticResults.count[sim, gen] <- sum(YChiasmaticResults[rows[4],] > 0)
Y.count <- sum(YChiasmaticResults[rows[2],])
YChiasmaticResults.prop[sim, gen] <- YChiasmaticResults.count[sim, gen]/Y.count
# Get rows for next set
rows <- rows + 4
}
}
plot(YChiasmaticResults.prop[1,], type = "l", ylim=c(0,1),
xlab = "Generation", ylab = "Frequency Fusions",
main = "Chiasmatic Y High mu High s",
col = col.vec[1])
col.vec <- viridis(num_sims)
col.vec <- viridis(num_sims)
plot(YChiasmaticResults.prop[1,], type = "l", ylim=c(0,1),
xlab = "Generation", ylab = "Frequency Fusions",
main = "Chiasmatic Y High mu High s",
col = col.vec[1])
library("viridisLite")
col.vec <- viridis(num_sims)
col.vec <- viridis(runs)
plot(YChiasmaticResults.prop[1,], type = "l", ylim=c(0,1),
xlab = "Generation", ylab = "Frequency Fusions",
main = "Chiasmatic Y High mu High s",
col = col.vec[1])
for(i in 2:nrow(CX_YChiasmaticResults.prop)){
lines(y = YChiasmaticResults.prop[i, ], x = 1:ncol(YChiasmaticResults.prop), col = col.vec[i])
}
for(i in 2:nrow(YChiasmaticResults.prop)){
lines(y = YChiasmaticResults.prop[i, ], x = 1:ncol(YChiasmaticResults.prop), col = col.vec[i])
}
update.packages(ask = FALSE, checkBuilt = TRUE)
shiny::runApp('C:/Users/knigh/Documents/GitHub/CaveCrawler/cavecrawler')
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# This function finds the minimum and maximum values for a population-specific
# statistic in a statistical table
MinMax <- function(mm_pops, mm_stat, stat_table){
# Create matrix to store all columns which house the morphs-of-interest
cols.w.morphs <- data.frame(matrix(nrow = length(mm_pops),
ncol = ncol(stat_table)))
colnames(cols.w.morphs) <- colnames(stat_table)
# Find all columns of stat_table which house at least one morph-of-interest
for(m in 1:length(mm_pops)){
cols.w.morphs[m,] <- grepl(mm_pops[m], names(stat_table),
ignore.case = T)
}
cols.of.interest <- c()
for(i in 1:ncol(cols.w.morphs)){
if(sum(cols.w.morphs[,i]) > 0){
cols.of.interest <- append(cols.of.interest, names(cols.w.morphs)[i])
}
}
# Of the columns of stat_table which house at least one morph-of-interest,
# exclude the columns which have morphs which are NOT morphs of interest
bad.morphs <- c("Pachon", "Rascon", "RioChoy", "Molino", "Tinaja")
for(i in 1:length(mm_pops)){
bad.morphs <- bad.morphs[bad.morphs != mm_pops[i]]
}
for(b in 1:length(bad.morphs)){
if(sum(grepl(bad.morphs[b], cols.of.interest,ignore.case = T)) != 0){
cols.of.interest <- cols.of.interest[!(grepl(bad.morphs[b],
cols.of.interest,
ignore.case = T))]
}
}
# Find columns-of-interest which house stat-of-interest
cols.of.interest <- cols.of.interest[grepl(mm_stat,
cols.of.interest,
ignore.case = T)]
# Combine columns-of-interest into a single vector of numbers
num_pool <- c()
for(i in 1:length(cols.of.interest)){
num_pool <- append(num_pool,
stat_table[,names(stat_table) == cols.of.interest[i]])
}
# Output the minimum and maximum values in that vector
minimum <- num_pool[which.min(num_pool)]
maximum <- num_pool[which.max(num_pool)]
return(list(minimum,maximum))
}
mm_pops = "Pachon"
``` mm_pops = "Pachon"
in_table = condition_control
# Create matrix to store all columns which house the morphs-of-interest
cols.w.morphs <- data.frame(matrix(nrow = length(mm_pops),
ncol = ncol(in_table)))
cols.w.morphs
colnames(cols.w.morphs) <- colnames(in_table)
cols.w.morphs
View(condition_control)
input$morph1
input$morph1 <- "Rio Choy"
input <- vector(mode = "list")
input$morph1 <- "Rio Choy"
(input$morph1 %in% condition_control$Comparison)
condition_control$Comparison
input$morph1
input$morph1 %in% condition_control$Comparison
input$morph1 <- "Control"
paste(c(input$morph1, "-", input$morph2), collapse = "")
input$morph1
input$morph2
input$morph1 <- "Rio Choy"
input$morph2 <- "Control"
paste(c(input$morph1, "-", input$morph2), collapse = "")
(paste(c(input$morph1, "-", input$morph2), collapse = "") %in% condition_control$Comparison)
(paste(c(input$morph1, "-", input$morph2), collapse = "")
%in% condition_control$Comparison)
input$condition <- "Sleep deprivation"
condition_control$logFC[
(paste(c(input$morph1, "-", input$morph2), collapse = "")
%in% condition_control$Comparison) &
(condition_control$Condition == input$condition)]
min(condition_control$logFC[
(paste(c(input$morph1, "-", input$morph2), collapse = "")
%in% condition_control$Comparison) &
(condition_control$Condition == input$condition)])
sec.table <- condition_control$logFC[
(paste(c(input$morph1, "-", input$morph2), collapse = "")
%in% condition_control$Comparison) &
(condition_control$Condition == input$condition)]
sec.table
View(morph1.morph2)
morph1.morph2$logFC[
(paste(c(input$morph1, "-", input$morph2), collapse = "")
%in% morph1.morph2$Comparison)]
input$morph2 <- "Pachon"
morph1.morph2$logFC[
(paste(c(input$morph1, "-", input$morph2), collapse = "")
%in% morph1.morph2$Comparison)]
grepl(input$morph1, morph1.morph2$Comparison)
grepl(input$morph2, morph1.morph2$Comparison)
input$morph2
input$morph1
sec.table <- morph1.morph2$logFC[
grepl(input$morph1, morph1.morph2$Comparison) &
grepl(input$morph2, morph1.morph2$Comparison)
]
sec.table
min(sec.table)
round(min(sec.table), 2)
round(min(sec.table), 2)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
