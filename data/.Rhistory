"p-value for log(FC)_Tinaja-RioChoy",
"Publications"
)
return(output.df)
}
GeneCentered(input = "jak1", stat_table, GeneToGO, condition_control,
position_table)
runApp('CaveCrawler.R')
runApp('CaveCrawler.R')
library(shiny); runApp('CaveCrawler.R')
morph1 = "Pachon"
morph2 = "Rio Choy"
condition = "Downregulated"
direction = "Downregulated"
condition = "Between morph"
percent = 10
GOTable = GeneToGO
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
# If condition is NOT "Between morph"...
if(condition != "Between morph"){
# Use transcription data of morph-control comparisons
in_table <- condition_control
# Set morph2 to control
morph2 <- "Control"
# Set grep pattern to morph1
search_cond <- morph1
# If searching between morphs, set search condition to morphs-of-comparison
}else if(condition == "Between morph"){
# Use transcription data for between-morph comparisons
in_table <- morph1.morph2
# Set grep pattern to comparison
search_cond <- paste(c(morph1, morph2), collapse = "-")
}
# Store comparison for output. Note: "morph2" is control if "Between morph"
# was not entered
comp <- paste(c(morph1, morph2), collapse = "-")
# Find all rows-of-interest (ROIs) for morph-of-interest where genes are
# downregulated, condition matches the input specification, and p-value is
# less than 0.05
ROIs <- in_table[(grepl(search_cond, in_table$Comparison)
& (in_table$logFC < 0) &
(in_table$Condition == condition)), ]
ROIs
ROIs$Gene_stable_ID[i]
grep(ROIs$Gene_stable_ID[i], GeneToGO$Ensembl)
length(grep(ROIs$Gene_stable_ID[i], GeneToGO$Ensembl))
GeneToGO$Ensembl[1]
library(biomaRt)
# define biomart object
mart <- useMart(biomart = "ensembl", dataset = "amexicanus_gene_ensembl")
# query biomart
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = "ENSAMXT00000009054",
mart = mart)
results$ensembl_gene_id
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
names(GeneToGO)[1] <- "Entry"
GeneToGO$Ensembl_geneID <- rep(NA, nrow(GeneToGO))
# query biomart
for(i in 1:nrow(GeneToGO)){
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
View(GeneToGO)
?str_remove
GeneToGO$Ensembl_transcript <- str_remove_all(GeneToGO$Ensembl_transcript, ";")
library(stringr)
for(i in 1:nrow(GeneToGO)){
GeneToGO$Ensembl_transcript <- str_remove_all(GeneToGO$Ensembl_transcript, ";")
}
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
names(GeneToGO)[1] <- "Entry"
# query biomart
for(i in 1:nrow(GeneToGO)){
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
setwd("C:/Users/knigh/Documents/GitHub/AstyanaxShinyApp/data")
GeneToGO$Ensembl_geneID <- rep(NA, nrow(GeneToGO))
# query biomart
for(i in 1:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
# query biomart
for(i in 1:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript[i],
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
View(GeneToGO)
View(GeneToGO)
View(GeneToGO)
View(GeneToGO)
for(i in 1:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript[i],
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
View(GeneToGO)
# query biomart
for(i in 44:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript[i],
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
# query biomart
for(i in 44:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript[i],
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
# query biomart
for(i in 49:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript[i],
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
# query biomart
for(i in 49:nrow(GeneToGO)){
print(paste(i, "/", nrow(GeneToGO)))
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript[i],
mart = mart)
GeneToGO$Ensembl_geneID[i] <- results$ensembl_gene_id
}
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
length(results)
GeneToGO$Ensembl_transcript
results <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
View(results)
GeneToGO$Ensembl_geneID <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
length(GeneToGO$Ensembl_transcript)
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
setwd("C:/Users/knigh/Documents/GitHub/AstyanaxShinyApp")
GeneToGO <- read.csv("data/AMexGOTerms.csv", fill = T)
GeneToGO$Gene.names <- tolower(GeneToGO$Gene.names)
names(GeneToGO)[1] <- "Entry"
# query biomart
GeneToGO$Ensembl_geneID <- getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
nrow(GeneToGO$Ensembl_transcript)
GeneToGO$Ensembl_transcript
length(GeneToGO$Ensembl_transcript)
getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = "k",
mart = mart)
length(getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = "k",
mart = mart)) == 0
length(getBM(attributes = "ensembl_gene_id",
filters = "ensembl_transcript_id", values = "k",
mart = mart))
# query biomart
results <- getBM(attributes = c("ensembl_gene_id", "ensembl_transcript_id", "ensembl_peptide_id"),
filters = "ensembl_transcript_id", values = GeneToGO$Ensembl_transcript,
mart = mart)
GeneToGO$Ensembl_GeneID <- results$ensembl_gene_id
GeneToGO$Ensembl_GeneID <- rep(NA, nrow(GeneToGO))
GeneToGO$Ensembl_GeneID[GeneToGO$Ensembl_transcript == results$ensembl_transcript_id[i]] <- results$ensembl_gene_id[i]
for(i in 1:nrow(results)){
GeneToGO$Ensembl_GeneID[GeneToGO$Ensembl_transcript == results$ensembl_transcript_id[i]] <- results$ensembl_gene_id[i]
}
setwd("C:/Users/knigh/Documents/GitHub/AstyanaxShinyApp/data")
write.csv(GeneToGO, "AMexGOTerms.csv")
View(position_table)
StatByChrTable <- function(GOTerm, GeneToGo, GoIDToNames, UpperLower,
stat_vec, position_table, stat_table, pops){
# Initialize vector for all GO terms of interest
GOs <- c()
# Initialize vector in which to store warnings
wrnings <- c("Notes: ")
# Check if user inputted a word/phrase or a GO ID. If the user inputted a
# word/phrase, find the name(s) which contains that word/phrase and set the GO
# vector equal to the corresponding GO IDs.
if(!(GOTerm %in% GoIDToNames$GO.ID)){
if(length(GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]) != 0){
GOs <- GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]
# If the input is not found in the GO terms but does have a comma,
# output both as GO IDs and check whether they are valid GO IDs
}else if((length(GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]) == 0)
& (grepl(", ", GOTerm, ignore.case = T))){
GOs <- str_split(GOTerm, ", ")[[1]]
# If the input is not found in the GO terms and does not have a comma,
# return an error
}else if((length(GoIDToNames$GO.ID[which(grepl(GOTerm, GoIDToNames$GO.Term,
ignore.case = T))]) == 0)
& !(grepl(", ", GOTerm, ignore.case = T))){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: Input is neither a valid GO ID nor a valid phrase",
null.df))
}
# If user inputted a GO ID, add that ID
}else if(GOTerm %in% GoIDToNames$GO.ID){
GOs <- GOTerm
}
# Find all GO terms which are LOWER than the GO terms in the GO vector.
# First, loop through each GO ID in the vector-of-GOs. As more GO IDs, are
# added to the vector, the number of remaining iterations will increase.
for(g in 1:length(GOs)){
# Add all "Lower" GO IDs which occur on a row where the current vector entry
# is an "Upper" to the vector of GO IDs, then move to the next GO ID
if(GOs[g] %in% UpperLower$Upper){
GOs <- append(GOs, UpperLower$Lower[UpperLower$Upper == GOs[g]])
# If the current GO ID does NOT occur anywhere in the "Upper" column, skip it
}else{
next
}
}
# Find all gene IDs associated with the current GO IDs and add to vector of gene IDs
GeneID_vec <- c()
found_GOs <- c()
for(g in 1:length(GOs)){
found = F
# If the GO term appears in the data frame of names AND the corresponding gene
# occurs in the statistics vector, add the GO term and gene name
for(i in 1:length(GeneToGO$Gene.ontology.IDs)){
if(grepl(GOs[g], GeneToGO$Gene.ontology.IDs[i])){
found = T
}else{
next
}
}
if(found){
GeneID_vec <- append(GeneID_vec, GeneToGO$Ensembl_GeneID[grepl(GOs[g],
GeneToGO$Gene.ontology.IDs)])
found_GOs <- append(found_GOs, rep(GOs[g],
length(GeneToGO$Ensembl_GeneID[grepl(GOs[g],
GeneToGO$Gene.ontology.IDs)])))
# If the GO term does NOT appear in the dataframe of names, skip it
}else{
next
}
}
# If no gene IDs were found corresponding to the current GO ID, return an error
if(is.null(GeneID_vec)){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("No genes were found corresponding to any of the input IDs or phrase",
null.df))
}else{
geneGOs <- data.frame(
GeneID = GeneID_vec,
GO_ID = found_GOs
)
geneGOs <- geneGOs[!duplicated(geneGOs), ]
}
# Extract all possible combinations of populations from populations of interest
if(("Fst" %in% stat_vec) | ("Dxy" %in% stat_vec)){
all_pops <- combn(pops,2)
two_pop <- T
}else{
two_pop <- F
}
# Create a temporary dataframe for all possible combinations of statistic
# types, columns, and the populations to which they correspond
stat_pop_combos <- data.frame(matrix(ncol = 3))
colnames(stat_pop_combos) <- c("Stat_Type", "Pop", "Col")
for(s in 1:length(stat_vec)){
# Check if statistic of interest makes comparisons between TWO populations
if((stat_vec[s] == "Fst") | (stat_vec[s] == "Dxy")){
# Check if all_pops was created
if(two_pop){
# If so, iterate through each combination and output stat value for that
# combination
for(pair in 1:ncol(all_pops)){
# If pops is a matrix, read the strings, find the column corresponding
# to the stat of interest for the populations in the vector, and set
# "index" equal to the column housing this statistic
val <- which(grepl(all_pops[1, pair], names(stat_table))
& grepl(all_pops[2, pair], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, add a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the populations ",
all_pops[1, pair]," and ",
all_pops[2, pair], " | "),collapse = ""))
# If these populations-of-interest are the only pops which were
# inputted, return a warning
if(ncol(all_pops) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list(paste(c("Statistic ",stat_vec[s],
" is not present for the populations ",
all_pops[1, pair]," and ",
all_pops[2, pair]),collapse = ""), null.df))
}
}else{
# Create a row to add to the indices data frame
temp_str <- paste(c(all_pops[1, pair],"-",all_pops[2, pair]),
collapse = "")
temp_vec <- c(stat_vec[s],temp_str,val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
# If pops is NOT a matrix, return an error
}
}else{
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list(paste(c("ERROR: Only one population, ", pops,
", supplied for the two-population statistic ",
stat_vec[s], "."),
collapse = ""), null.df))
# Check if statistic of interest makes comparisons between ONE population
}
}else if((stat_vec[s] == "TajimasD") | (stat_vec[s] == "Pi")){
# Iterate through each individual population
for(p in 1:length(pops)){
# If pops is a string, set indx equal to the column housing the stat of
# interest for this population
val <- which(grepl(pops[p], names(stat_table))
& grepl(stat_vec[s], names(stat_table)))
# If statistic for populations-of-interest is not present, return a
# warning
if(length(val) == 0){
wrnings <- append(wrnings, paste(c("Statistic ",stat_vec[s],
" is not present for the population ",
pops[p], " | "), collapse = ""))
}else{
# Create a row to add to the indices dataframe
temp_vec <- c(stat_vec[s],pops[p],val)
stat_pop_combos <- rbind(stat_pop_combos, temp_vec)
}
}
}
}
# If NONE of the populations-of-interest had values for the statistics-of-
# interest, output an error
if(nrow(stat_pop_combos) == 1){
null.df <- data.frame(matrix(nrow = 1, ncol = 9))
names(null.df) <- c("Gene",
"Scaffold",
"Start_Position",
"End_Position",
"GO_IDs",
"Statistic_Type",
"Population",
"Statistic_Value",
"Publication_Name")
return(list("ERROR: None of the input statistics are present for any of the input populations",
null.df))
}
# If dataframe was valid, remove first row (as this is all NAs from)
# initialization
stat_pop_combos <- stat_pop_combos[-1,]
# For each GO Term in the vector of GO Terms-of-interest, find...
# 1. All gene names which occur in the positions table AND in the statistics
#    table
# 2. The scaffolds of those genes
# 3. The starting positions of those genes
# 4. The ending positions of those genes
# 5. The GO terms associated with those genes
# 6. Each of the 4 statistic types
# 7. Each of the populations/population combinations
# 8. Each of the statistical values
# 9. Publication from which the statistic value was derived
# For each statistic-population pair, iterate through each gene and find the
# statistic value, scaffold, starting position, and ending position and
# output to a dataframe
GeneID <- c()
Scaffold <- c()
Start_Position <- c()
End_Position <- c()
GO_IDs <- c()
Statistic_Type <- c()
Population <- c()
Statistic_Value <- c()
Publication_Number <- c()
for(i in 1:nrow(stat_pop_combos)){
for(g in 1:length(geneGOs$Gene)){
# Check if current gene ID is in stat AND position table
# If so...
if((geneGOs$GeneID[g] %in% stat_table$Stable_Gene_ID) &
(geneGOs$GeneID[g] %in% position_table$Gene_ID)){
# Find the number of copies of the current gene ID in the statistic
# table
copies <- length(stat_table[stat_table$Stable_Gene_ID == geneGOs$GeneID[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the current gene as many times as there are copies
GeneID <- append(GeneID, rep(geneGOs$GeneID[g], copies))
# Output scaffold of current gene as many times as there are copies
Scaffold <- append(Scaffold,
rep(position_table$Scaffold[position_table$Gene_ID == geneGOs$GeneID[g]],
copies))
# Output starting position of the current gene as many times as
# there are copies of the gene
Start_Position <- append(Start_Position,
rep(position_table$Start_Locus[position_table$Gene_ID == geneGOs$GeneID[g]],
copies))
# Output the ending position of the current gene as many times as
# there are copies of the gene
End_Position <- append(End_Position,
rep(position_table$End_Locus[position_table$Gene_ID == geneGOs$GeneID[g]],
copies))
# Output ALL GO terms associated with the current gene ID as many times
# as there are copies of the gene
GO_IDs <- append(GO_IDs,
rep(
paste(geneGOs$GO_ID[geneGOs$GeneID == geneGOs$GeneID[g]], collapse = "; "),
copies))
# Output the current statistic type as many times as there are copies
# of the gene
Statistic_Type <- append(Statistic_Type,
rep(stat_pop_combos$Stat_Type[i],
copies))
# Output the population(s) which correspond to the current column,
# and output as many times as there are copies of the gene.
Population <- append(Population, rep(stat_pop_combos$Pop[i],
copies))
# Output the statistic value. Will automatically output value for
# each copy of the gene.
Statistic_Value <- append(Statistic_Value,
stat_table[stat_table$Stable_Gene_ID == geneGOs$GeneID[g],
as.numeric(stat_pop_combos$Col[i])])
# Output the publication from which the statistic was obtained
Publication_Number <- append(Publication_Number,
stat_table$Publication[stat_table$Stable_Gene_ID == geneGOs$GeneID[g]])
# If not, skip the gene
}else{
next
}
}
}
output_df <- data.frame(GeneID,
Scaffold,
Start_Position,
End_Position,
GO_IDs,
Statistic_Type,
Population,
Statistic_Value,
Publication_Number
)
# Remove all values where the stat-of-interest is NA
output_df <- output_df[!is.na(output_df$Statistic_Value), ]
return(list(wrnings, output_df))
}
StatByChrTable(GOTerm = "GO:0036359", GeneToGo, GoIDToNames, UpperLower,
stat_vec = "Fst", position_table, stat_table, pops = c("Rascon","Tinaja"))
StatByChrTable(GOTerm = "GO:0035639", GeneToGo, GoIDToNames, UpperLower,
stat_vec = "Fst", position_table, stat_table, pops = c("Rascon","Tinaja"))
x <- StatByChrTable(GOTerm = "GO:0035639", GeneToGo, GoIDToNames, UpperLower,
stat_vec = "Fst", position_table, stat_table, pops = c("Rascon","Tinaja"))
x <- StatByChrTable(GOTerm = "GO:0035639", GeneToGo, GoIDToNames, UpperLower,
stat_vec = "Fst", position_table, stat_table, pops = c("Rascon","Tinaja"))[[2]]
View(x)
GeneToGO$Gene.ontology.IDs <- GeneToGO$Gene.ontology.IDs[!is.na(GeneToGO$Gene.ontology.IDs)]
x <- StatByChrTable(GOTerm = "GO:0035639", GeneToGo, GoIDToNames, UpperLower,
stat_vec = "Fst", position_table, stat_table, pops = c("Rascon","Tinaja"))[[2]]
library(shiny); runApp('C:/Users/knigh/Documents/GitHub/AstyanaxShinyApp/CaveCrawler.R')
